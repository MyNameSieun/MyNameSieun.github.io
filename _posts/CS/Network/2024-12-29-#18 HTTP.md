---
title: "[Network] #18 HTTP"
categories: [Network]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[[혼자 공부하는 네트워크↗️]](https://www.youtube.com/watch?v=c62qssA4hYI&list=PLVsNizTWUw7HfOCgvlfHIDPPo3TE-2iQM), 컴퓨터 네트워킹: 하향식 접근 (제8판)을 바탕으로 정리한 글입니다.
{: .notice--danger}

- HTTP는 사용자와 밀접하게 맡닿아 있으며, 웹 세상의 기반이 되는 가장 중요한 프로토콜이다.
- 이번 포스팅에서는 HTTP의 네 가지 중요한 특성에 대해 자세히 알아보도록 하자.

---

<br>

# 1. HTTP 개요

- HTTP는 인터넷에서 데이터를 주고받기 위한 <span style="color:indianred">통신 프로토콜</span>이다.
- 클라이언트는 HTTP 요청 메세지를 생성하고, 해당 서버에 해당 서버의 주소(URL)와 함께 요청을 보낸다.<br><br>
  ![](https://velog.velcdn.com/images/sieunpark/post/f8d67d91-bbff-46c1-8099-d0f584bd5d8c/image.png)

<br>

> 서버와 클라이언트의 개념은 상대적이다!

아래 사진에서 웹브라우저가 웹서버에 날씨데이터를 요청하고, 웹서버는 다시 기상청 서버에 데이터를 요청 후 리턴을 받아 그 결과를 웹브라우저에게 전달한다.

이때 웹서버는 서버의 역할도 하지만, 데이터를 요청하는 클라이언트의 역할도 한다.

![](/assets/images/2024/2024-02-25-23-07-52.png)

<br><br>

# 2. HTTP의 네 가지 특성

## 2.1 요청-응답 기반 프로토콜

> HTTP는 클라이언트-서버 구조 기반의 요청-응답 프로토콜이다.

- 클라이언트는 HTTP 요청 메시지를 서버로 전송하고, 서버는 이에 대한 HTTP 응답 메시지를 반환한다.
- HTTP 요청 메시지와 HTTP 응답 메시지는 메시지 형태가 다르다. -웹 브라우저의 개발자 도구 > 네트워크 탭에서 요청과 응답 메시지를 확인할 수 있다.<br><br>![](/assets/images/2024/2024-12-29-00-43-54.png)

<br>

## 2.2 미디어 독립적 프로토콜

> HTTP는 주고받을 자원의 종류와 무관하게 동작하는 미디어 독립적 프로토콜이다.

- 그저 자원을 주고받을 수단(인터페이스) 역할만 한다.
- HTTP를 통해 HTML, JPEG, PNG, JSON, XML, PDF 등 다양한 형식의 자원을 송수신할 수 있다.

<br>

### 2.2.1 미디어 타입(Media Type)

> 미디어 타입(Media Type)이란, HTTP에서 자원의 종류를 나타내는 방식이며 MIME 타입이라고도 불린다.

즉, HTTP는 주고받을 미디어 타입에 특별히 제한을 두지 않고 동작하는 미디어 독립적 프로토콜이다.

![](/assets/images/2024/2024-12-29-00-49-27.png)

<br>

### 2.2.2 미디어 타입의 구성과 종류

> 슬래시를 기준으로 `타입/서브타입` 형식으로 구성한다.

- 타입(type): 데이터의 유형
- 서브타입(subtype) - 주어진 타입에 대한 세부 유형

> 미디어 타입에는 부가적인 설명을 위해 선택적으로 매개변수를 포함할 수 있다.

- `타입/서브타입;매개변수=값`의 형식으로 표현된다. (`type/subtype;parameter=value`)
- e.g., `type/html; charset=UTF-8`

> 여러 미디어 타입을 통칭하고자 할 때는 와일드카드(\*)를 사용하면 된다.

- `text/*`: text 타입의 모든 서브타입
- `image/*`: image 타입의 모든 서브타입
- `*/*`: 모든 미디어 타입

<br>

> 미디어 타입의 종류는 매우 다양하며, 새로운 미디어 타입을 등록할 수도 있다.

![](/assets/images/2024/2024-12-29-00-53-04.png)

![](/assets/images/2024/2024-12-29-00-53-58.png)

<br>

## 2.3 stateless 프로토콜

> HTTP는 상태를 유지하지 않는 stateless 프로토콜이다.

- 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다는 의미이다.
- 클라이언트의 모든 HTTP 요청은 기본적으로 독립적인 요청으로 간주된다.<br><br>![](/assets/images/2024/2024-12-29-01-12-55.png)

<br>

> 왜 HTTP는 상태를 유지하지 않을까?

① HTTP 서버는 일반적으로 많은 클라이언트와 동시에 상호 작용을 하기 때문에, 모든 클라이언트의 상태 정보를 유지하는 것은 서버의 큰 부담이 되기 때문이다.<br><br>![](/assets/images/2024/2024-12-29-01-20-01.png)

<br>

② 특정 클라이언트가 특정 서버에 종속되는 상황을 방지하기 위해서이다.

- 상태를 유지하지 않으면 서버에 문제가 생겨도 다른 서버로 대체가 용이하다.
- HTTP가 상태를 유지하는 프로토콜이라면, 클라이언트는 자신의 상태를 기억하는 특정 서버하고만 통신할 수 있다.<br><br>![](/assets/images/2024/2024-12-29-01-22-45.png)

<br>

즉, stateless 프로토콜은 확장성과 견고성에 유리하다.

<br>

## 2.4 지속 연결을 지원하는 프로토콜

> 비지속 연결

- 초기의 HTTP 버전(HTTP 1.0 이하)
- TCP 연결 수립한 후, 요청을 대한 응답을 받으면 연결 종료
- 추가적인 요청-응답을 하기 위해서는 다시 TCP 연결 수립부터 반복

<br>

> 지속 연결(persistent connection) 또는 킵 얼라이브(keep-alive)

- 최근 대중적으로 사용되는 HTTP 버전(HTTP 1.1 이상)
- 하나의 TCP 연결상에서 여러 개의 요청-응답을 주고받을 수 있는 기술

<br>

![](/assets/images/2024/2024-12-29-01-29-20.png)

<br><br>

# 3. HTTP 메시지 구조

> HTTP 메시지는 시작라인, 필드라인, 메시지 본문으로 구성되어있다.

- 필드라인은 없거나 여러개 있을 수 있다.
- 메시지 본문은 없을 수 있다.
- 필드 라인과 메시지 본문 사이에는 빈 줄바꿈이 있다.

![](/assets/images/2024/2024-12-29-01-30-13.png)

<br>

## 3.1 시작 라인 (start-line)

> HTTP 메시지는 HTTP 요청 메시지일 수도 있고, HTTP 응답 메시지일 수도 있다.

- HTTP 메시지가 HTTP 요청 메시지일 경우: 시작 라인 = "요청 라인"
- HTTP 메시지가 HTTP 응답 메시지일 경우: 시작 라인 = "상태 라인"<br><br>
  ![](/assets/images/2024/2024-12-29-01-31-26.png)

<br>

### 3.1.1 시작 라인 - 요청 라인

![](/assets/images/2024/2024-12-29-01-33-11.png)

<br>

> ① 메서드 (method)

- 클라이언트가 서버의 자원(요청 대상)에 대해 수행할 작업의 종류를 의미한다.
- 대표적으로 GET, POST, PUT, DELETE 등이 존재한다.

<br>

> ② 요청 대상 (request-target)

- HTTP 요청을 보낼 서버의 자원을 의미한다.
- 보통 (쿼리가 포함된) URI의 경로가 명시된다.
  - e.g., 클라이언트가 "http://www.example.com<span style="color:indianred">/hello?q=world</span>"로 요청 -> 요청 대상은 "hello?q=world"
  - 만약 하위 경로가 없더라도 요청 대상은 슬래시(/)로 표기

<br>

> ③ HTTP 버전

- 사용된 HTTP 버전
- `HTTP/<버전>`이라는 표기 방식을 따르며, HTTP 버전 1.1은 HTTP/1.1 로 표기

<br>

### 3.1.2 시작 라인 - 상태 라인

![](/assets/images/2024/2024-12-30-23-30-26.png)

<br>

> 상태 코드, 이유 구문

- 상태 코드
  - 요청에 대한 결과를 내타내는 세 자리 정수
  - e.g., HTTP/1.1 <span style="color:indianred">200</span> OK, HTTP/1.1 <span style="color:indianred">404</span> Not Found
- 이유 구문
  - 상태 코드에 대한 문자열 형태의 설명
  - e.g., HTTP/1.1 200 <span style="color:indianred">OK</span>, HTTP/1.1 404 <span style="color:indianred">Not Found</span>

<br>

## 3.2 필드라인 (= 헤드라인)

> 0개 이상의 HTTP 헤더가 명시된다.

- HTTP 헤더란, HTTP 통신에 필요한 부가 정보를 의미한다.
- 콜론(:)을 기준으로 헤더 이름과 하나 이상의 헤더 값으로 구성된다.<br><br>![](/assets/images/2024/2024-12-30-23-34-20.png)

<br>

## 3.3 메시지 본문

> HTTP 요청 혹은 응답 메시지에서 본문이 필요한 경우 선택적으로 메시지 본문에 명시된다.

다양한 콘텐츠 타입을 사용할 수 있다.

![](/assets/images/2024/2024-12-30-23-36-22.png)

<br>

## 3.4. HTTP 메시지 구조 정리

> HTTP는 미디어 독립적인 프로토콜이므로 메시지 본문에는 어느 데이터가 명시되던 상관이 없다.

- 따라서 HTTP를 학습할 때에는 시작라인, 필드라인 위주로 학습을 진행해야 한다.
- 이번 포스팅에서는 요청 라인의 메서드와 상태 라인의 상태 코드, 이유 구문을 중점적으로 알아보도록 하자.

![](/assets/images/2024/2024-12-30-23-37-57.png)

<br><br>

# 4. HTTP 메서드

| 요청 메서드 |                                                 설명                                                 |
| :---------: | :--------------------------------------------------------------------------------------------------: |
|     GET     |                        자원 가져오기, 요청의 본문(body)에 데이터를 넣지 않음                         |
|    HEAD     |                   GET과 동일하지만, 응답 본문(body)을 포함하지 않고 헤더만을 반환                    |
|    POST     | - 서버로 하여금 특정 작업을 처리하게끔 하는 메서드<br>- 요청의 본문에 새로 등록할 데이터를 넣어 보냄 |
|   DELETE    |                    자원 삭제, 요청의 본문에 데이터를 넣지 않음 (URL로 자원 지정)                     |
|     PUT     |            자원 전체 업데이트 (본문에 전체 데이터 포함), 자원이 존재하지 않으면 새로 생성            |
|    PATCH    |                             자원 부분 업데이트 (본문에 부분 데이터 포함)                             |

<br>

## 4.1 GET - 조회

> 특정 자원을 <span style="color:indianred">조회</span>할 때 사용하는 메서드 (e.g., 웹 브라우저 URL 입력)

- 클라이언트가 서버에게 "이것을 가져다 주세요"라 요청을 보내는 것과 같다.
- "이것" = 자원(HTML, JSON, 이미지 파일이나 일반 텍스트 파일 등)

<br>

> 요청 메시지

`http://www/example.com/example-page` 에 대한 간략한 GET 요청 메시지

![](/assets/images/2024/2024-12-30-23-43-42.png)

<br>

GET 요청 메시지에는 메시지 본문보다 쿼리 문자열이 사용되는 경우가 많다.

![](/assets/images/2024/2024-12-30-23-46-02.png)

<br>

> 응답 메시지

GET 요청 메시지가 성공적으로 처리되었다면, 이에 대한 응답으로서 요청한 자원을 전달받는다.

![](/assets/images/2024/2024-12-30-23-47-04.png)

<br>

## 4.2 HEAD - 헤더 조회

> HEAD 메서드를 사용하면, 서버는 요청에 대한 응답으로 응답 메시지의 헤더만 반환한다.

자원의 메타데이터를 확인하고 싶을 때 (e.g., 콘텐츠 길이, 수정 시간, 콘텐츠 타입 등), 서버와의 트래픽을 줄이기 위해 응답 본문을 받지 않고, 헤더만으로 상태를 파악할 때 사용된다.

<br>

> 요청 메시지

`http://www/example.com/example-page` 에 대한 HEAD 요청을 보낸 예시

![](/assets/images/2024/2024-12-30-23-48-42.png)

<br>

> 응답 메시지

![](/assets/images/2024/2024-12-30-23-49-26.png)

<br>

## 4.2 POST - 등록

> 서버로 하여금 <span style="color:indianred">특정 작업을 처리 하도록 요청</span>하는 메서드

클라이언트의 입력 폼 작성 뒤 [게시하기] 버튼 클릭 가정

![](/assets/images/2024/2024-12-30-23-50-12.png)

<br>

> 처리할 대상은 흔히 메시지 본문으로 명시된다.

GET 메서드 달리 POST 메서드는 메시지 본문을 명시한다.

![](/assets/images/2024/2024-12-30-23-51-39.png)

<br>

> POST 메서드는 많은 경우 "<span style="color:indianred">클라이언트가 서버에 새로운 자원을 생성하고자 할 때</span>" 사용한다.

- 새로운 자원이 생성 되었다면, 서버는 응답 메시지의 Location 헤더를 통해 새로 생성된 자원의 위치를 알려준다.
- e.g., 게시하기 버튼 눌러 게시판에 글이 등록 되었을 때, 글이 등록된 url 위치를 location을 통해 응답 받을 수 있다.<br><br>![](/assets/images/2024/2024-12-30-23-53-34.png)

<br>

## 4.3 PUT - 전체 수정(덮어쓰기)

> - 요청 자원이 없다면 메시지 본문으로 자원을 새롭게 생성<br>
> - 요청 자원이 존재한다면 메시지 본문으로 자원을 새롭게 대체

![](/assets/images/2024/2024-12-30-23-57-33.png)

<br>

## 4.4 PATCH - 부분 수정

> 메시지 본문에 맞게 자원 일부를 수정하는 메서드

아래 그림은 앞선 예제의 요청 메서드를 PATCH 메서드로 바꿔 보낸 결과이다.

![](/assets/images/2024/2024-12-30-23-59-16.png)

<br>

## 4.5 DELETE - 삭제

> 특정 자원을 삭제하는 메서드

아래는 `example.com/texts/a.txt`라는 자원을 삭제하도록 요청하는 메시지

![](/assets/images/2024/2024-12-31-00-01-22.png)

<br><br>

# 5. HTTP 상태 코드

## 5.1 상태 코드

> 상태 코드의 종류는 <span style="color:indianred">백의 자리 수</span>를 기준으로 유형을 구분한다.

![](/assets/images/2024/2024-12-31-01-24-03.png)

<br>

## 5.2 200번대 - 성공 상태 코드

> 요청이 성공했음을 의미한다.

![](/assets/images/2024/2024-12-31-01-25-04.png)

<br>

### 5.2.1 200 (OK)

> "http://example.com/images/a.png"로 GET 요청을 성공적으로 보낸 경우, 상태코드 200 (OK)를 응답한다.

아래와 같이 요청한 자원을 메시지 본문을 통해서 응답 받을 수 있다.

![](/assets/images/2024/2024-12-31-01-27-10.png)

<br>

### 5.2.2 201 (Created)

> POST 요청으로 서버에 새로운 자원을 생성한 경우, 상태 코드 201 (Created)를 응답한다.

이때, <span style="color:indianred">Location 헤더</span>를 통해 생성된 자원의 위치를 명시한다.<br><br>![](/assets/images/2024/2024-12-31-01-30-24.png)

<br>

### 5.2.3 202 (Accepted)

> 요청을 잘 받았으나 아직 요청한 작업을 끝내지 않았을 경우, 상태코드 202 (Accepted)를 응답한다.

- 즉, 요청 결과를 곧바로 응답하기 어려운 경우
- e.g., 작업 시간이 긴 대용량 파일 업로드 작업 등

<br>

### 5.2.4 204 (No Content)

> 요청을 잘 받았고, 마땅히 본문으로 표현할 것이 없을 경우, 상태코드 204 (No Content)를 응답한다.

![](/assets/images/2024/2024-12-31-01-32-55.png)

<br>

## 5.3 300번대 - 리다이렉션 상태 코드

### 5.3.1 리다이렉션?

> 리다이렉션(redireaction)이란, 요청을 완수하기 위한 추가적인 조치가 필요한 상태를 의미한다.

e.g., 클라이언트가 요청한 자원이 다른 곳에 있을 때, 클라이언트의 요청을 다른 곳으로 이동

![](/assets/images/2024/2024-12-31-01-36-45.png)

<br>

### 5.3.2 영구적인 리다이렉션

> 자원이 완전히 새로운 곳으로 이동하여 요청을 보내야하는 경로가 영구적으로 재지정 되었을 때, 영구적인 리다이렉션(permanent redirection)이라고 한다.

- 위 예시의 경우, 기존의 URL의 요청 메시지를 보내면 항상 새로운 URL로 리다이렉트
- 영구적인 리다이렉션이 일어날 경우, 영구적으로 자원이 이동했기 때문에 클라이언트 입장에서 기존의 URL을 기억할 필요가 없다.<br><br>![](/assets/images/2024/2024-12-31-01-46-42.png)

<br>

### 5.3.3 일시적인 리다이렉션

> 자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 주로 사용 된다.

어떤 URL에 대해 일시적인 리다이렉션 관련 상태 코드를 응답 받았다면 여전히 요청을 보낸 URL은 기억한다.

![](/assets/images/2024/2024-12-31-01-44-23.png)

<br>

## 5.4 400번대 - 클라이언트 에러 상태 코드

> 클라이언트에 의한 에러가 있음을 알려 주는 상태 코드이다.

![](/assets/images/2024/2024-12-31-01-49-00.png)

<br>

### 5.4.1 400 (Bad Request)

> 클라이언트의 요청이 잘못되었음을 알려 주는 상태 코드

![](/assets/images/2024/2024-12-31-02-00-03.png)

<br>

### 5.4.2 401 (Unauthorized)

> 요청에 대한 인증이 필요할 경우 서버는 401 (Unauthorized)을 응답

서버가 상태 코드 401로 응답할 때는 반드시 `WWW-Authenticate` 라는 헤더를 통해 인증 방법을 알려줘야한다.

![](/assets/images/2024/2024-12-31-02-01-43.png)

<br>

### 5.4.3 403 (Forbidden)

> 클라이언트 권한이 충분하지 않다면 상태코드 403 (Forbidden)를 응답

![](/assets/images/2024/2024-12-31-02-02-10.png)

<br>

> 인증(Authentication) 여부와 권한 부여(Authorization) 여부

- 인증
  - 자신이 누구인지 증명하는 것
  - "너 누구야!"
- 권한 부여/인가
  - 인증된 주체에게 작업을 허용하는 것
  - "너 뭐 돼?"

<br>

### 5.4.4 404 (NotFound)

> 접근하고자 하는 자원이 존재하지 않음을 알리는 상태 코드

존재하지만 공개하지 않는 자원에 대해 404(NotFound)를 응답하는 경우도 있다.

![](/assets/images/2024/2024-12-31-02-05-17.png)

<br>

### 5.4.5 405 (Method Not Allowed)

> 구현되지 않는 메서드로 요청을 보낼 경우 싱태 코드 405 (Method Not Allowed)를 응답

![](/assets/images/2024/2024-12-31-02-05-55.png)

<br>

## 5.5 500번대 - 서버 에러 상태 코드

> 클라이언트가 올바르게 요청을 보냈을지라도 발생할 수 있는 서버에 대한 상태 코드

서버 잘못 (서버 폭파, 서버 오류 등으로 응답을 줄 수 없는 상태)

![](/assets/images/2024/2024-12-31-02-08-14.png)

<br>

### 5.5.1 500 (Internal Server Error)

> 서버의 예기치 못한 상황으로 인해 요청을 처리할 수 없음을 알리는 상태 코드

상태 코드 500은 서버 에러를 통칭한다.

![](/assets/images/2024/2024-12-31-02-09-18.png)

<br>

### 5.5.2 502 (Bad Gateway)

> 클라이언트와 서버 사이에 위치한 중간 서버의 통신 오류를 나타내는 상태 코드

중간 서버가 유효하지 않거나 잘못 된 응답을 받을 때 볼 수 있는 상태

![](/assets/images/2024/2024-12-31-02-11-02.png)

<br>

### 5.5.3 503 (Service Unavailable)

> 현재 서비스를 일시적으로 이용할 수 없음을 알리는 상태 코드

서버가 과부하 상태에 있거나 일시적인 점검 상태일 때 볼 수 있는 상태

<br><br>

# 6. HTTP 발전

## 6.1 HTTP/0.9

- 현재 거의 사용되지 않는 초창기 HTTP 버전
- 사용 가능한 메서드: GET
- 헤더 지원 X

<br>

## 6.2 HTTP/1.0

- HEAD, POST 등 GET 이외에 메서드 도입
- 헤더 지원 시작
- 공식적으로는 지속 연결 미지원

<br>

## 6.3 HTTP/1.1📌

> 오늘날까지도 널리 사용되는 버전

- 지속 연결 공식적 지원
- 파이프라이닝, 콘텐츠 협상 기능 등 다양한 편의 기능 추가
- 메시지 본문 = 평문

<br>

> HTTP 1.1의 고질적 문제, HOL 블로킹(Head-of-line blocking)

- 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 경우,
- 첫 번째 패킷의 처리 지연으로 인해 나머지 패킷 처리도 모두 지연되는 문제 상황

![](/assets/images/2024/2024-12-31-02-16-50.png)

<br>

## 6.4 HTTP/2.0

> 오늘날까지 널리 사용되는 버전

- HTTP/1.1의 효율과 성능을 높이기 위한 버전
- 메시지 본문 = 바이너리 데이터
- 헤더 압축 전송 기능

<br>

> 서버 푸시(sercer push) 기능

클라이언트가 요청하지 않았더라도 미래에 필요할 것으로 예상되는 자원을 미리 전송하는 기능

![](/assets/images/2024/2024-12-31-02-19-42.png)

<br>

> HTTP 멀티 플랙싱(multiplexing)을 통한 HOL 블로킹 완화

- 여러 스트림(stream)을 활용해 병렬적으로 메시지를 주고받는 기술
- 요청-응답 단위는 하나의 스트림에서 이루어짐
- 스트림별 독립적인 송수신 가능
- 별도의 스트림을 통해 여러 데이터를 병렬적으로 주고받으며 HOL 블로킹 완화

<br>

## 6.5 HTTP/3.0

> 오늘날 점차 사용 확대되는 버전

- 이전까지의 HTTP 버전 = TCP 기반 동작
- HTTP/3.0 = UDP 기반 프롵콜인 QUIC(Quick UDP Internet COnnections) 기반으로 동작
- 연결형 프로토콜 기반 송수신 속도 < 비연결형 프로토콜 기반 프로토콜 송수신 속도

<br>
