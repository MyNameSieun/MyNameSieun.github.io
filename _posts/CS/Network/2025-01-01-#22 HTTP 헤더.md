---
title: "[Network] #22 HTTP 헤더"
categories: [Network]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[[혼자 공부하는 네트워크↗️]](https://www.youtube.com/watch?v=c62qssA4hYI&list=PLVsNizTWUw7HfOCgvlfHIDPPo3TE-2iQM), 컴퓨터 네트워킹: 하향식 접근 (제8판)을 바탕으로 정리한 글입니다.
{: .notice--danger}

- 저번 포스팅에서는 시작 라인의 요청 메시지의 경우 시작 라인은 요청 라인이 되고, 응답 메시지의 경우엔 시작 라인이 상태 라인이 된다고 하였다.
- 이와 관련해서 요청 라인에 명시되는 메서드와 상태 라인에 명시되는 상태 코드와 이유 구문에 대해 학습을 했다.
- 이번 포스팅에서는 필드 라인에 명시되는 다양한 헤더들을 학습할 것이다.<br><br>
  ![](/assets/images/2024/2024-12-30-23-37-57.png)

<br>

# 1. 필드라인 (=헤더라인)

## 1.1 HTTP 헤더란?

> 0개 이상의 HTTP 헤더가 명시된다.

- HTTP 헤더란, HTTP 통신에 필요한 부가 정보를 의미한다.
- 콜론(:)을 기준으로 헤더 이름과 하나 이상의 헤더 값으로 구성된다.<br><br>![](/assets/images/2024/2024-12-31-02-26-12.png)

<br>

## 1.2 헤더 유형

> 특별한 사전 지식이 필요하지 않은 헤더

- HTTP 요청/응답/요청·응답 모두 에서 주로 사용되는 헤더
- -> 이번 포스팅에서 다룰 내용

> 사전 지식이 필요한 헤더

- e.g., 캐시, 쿠키, 콘텐츠 협상 관련 헤더
- -> 다음 포스팅에서 다룰 내용<br><br>
  ![](/assets/images/2024/2024-12-30-23-34-20.png)

<br>

## 1.3 메시지 본문과 표현

> 메시지 본문

- 메시지 본문(message body)을 통해 표현 데이터를 전달한다.
- 메시지 본문 = 페이로드(payload)

> 표현

- 표현은 요청이나 응답에서 전달할 실제 데이터이다.
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보를 제공하며, **HTTP 요청과 응답 모두 사용** 한다.
- e.g., 데이터 유형(html, json), 데이터 길이, 압축 정보 등등<br><br>
  ![](/assets/images/2025/2025-01-02-00-54-44.png)

<br>

> 표현 헤더

| **헤더**             | **설명**                |
| -------------------- | ----------------------- |
| **Content-Type**     | 표현 데이터의 형식      |
| **Content-Encoding** | 표현 데이터의 압축 방식 |
| **Content-Language** | 표현 데이터의 자연 언어 |
| **Content-Length**   | 표현 데이터의 길이      |

<br><br>

# 2. HTTP 요청과 응답 모두에서 자주 활용되는 헤더

💡 Content-Type, Content-Encoding, Content-Language, Content-Length는 메시지 본문의 표현 방식을 설명하는 헤더이다.

<br>

## 2.1 Content-Type: 표현 데이터의 형식

> 서버가 클라이언트에게 보내는 **표현 데이터의 형식**을 지정하는 헤더이다. 이 헤더를 통해 클라이언트는 서버에서 받은 데이터가 어떤 종류의 콘텐츠인지 알 수 있다.

- e.g.,
  - `text/html`: HTML 문서
  - `application/json`: JSON 데이터
  - `image/png`: PNG 이미지
  - `application/xml`: XML 데이터
- 사용 예시
  - 서버가 `application/json`을 Content-Type으로 설정하면, 클라이언트는 받은 데이터가 JSON 형식임을 알고 JSON 파서로 처리할 수 있다.<br><br>
    ![](/assets/images/2025/2025-01-02-01-26-14.png)

<br>

## 2.2 Content-Encoding: 표현 데이터의 압축 방식

> 서버가 클라이언트에게 보내는 데이터가 **어떤 방식으로 압축되었는지** 알려주는 헤더이다. 클라이언트는 이 정보를 바탕으로 데이터를 올바르게 압축 해제해야 한다.

- e.g.,
  - gzip: gzip 압축
  - deflate: deflate 압축
  - br: Brotli 압축
- 사용 예시
  - 서버가 Content-Encoding: gzip을 설정하면, 클라이언트는 gzip 압축을 해제한 후 데이터를 처리해야 한다.<br><br>
    ![](/assets/images/2025/2025-01-02-01-31-22.png)
    ![](/assets/images/2024/2024-12-31-15-21-23.png)

<br>

## 2.3 Content-Language: 표현 데이터의 자연 언어

> 표현 데이터의 자연 언어를 지정하는 헤더이다. 클라이언트가 콘텐츠를 어떤 언어로 해석해야 할지를 알려준다.

- 메시지 본문에 사용된 자연연어를 명시
- 언어 태그로 명시: 하이픈(-)으로 구분된 구조
  - `언어 코드 - 국가 코드`의 조합
  - 일반적으로 첫 번째 `서브 태그 = 언어 코드`, `두 번째 서브 태그 = 국가 코드`
  - 어떤 국가에서 사용하는 어떤 언어인지를 나타낸다.
- e.g.,
  - `ko-KR`, `en-GB`, `en-US`
- 사용 예시
  - 서버가 Content-Language: en을 설정하면, 클라이언트는 콘텐츠가 영어로 작성되었다고 인식하고, 이를 적절히 표시한다.<br><br>
    ![](/assets/images/2025/2025-01-02-01-36-10.png)

<br>

## 2.4 Content-Length: 표현 데이터의 길이

> 표현 데이터의 **바이트 단위** 길이를 지정하는 헤더이다. 이 값은 클라이언트가 수신할 데이터의 크기를 미리 알 수 있게 해준다.

- Transger-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안된다.
- e.g.,
  - Content-Length: 1234: 데이터 길이가 1234 바이트라는 의미
- 사용 예시
  - 클라이언트가 Content-Length 헤더를 확인하고, 해당 크기만큼 데이터를 받아들여야 한다.
  - 예를 들어, 클라이언트가 1234 바이트의 데이터를 받으면, 그것이 끝나면 전송이 완료되었다고 인식한다.<br><br>
    ![](/assets/images/2025/2025-01-02-01-39-17.png)

<br>

## 2.5 Connection

> 클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더

- 지속 연결이 Connection에 명시되는 대표적인 연결 방식
- 가장 대표적으로 사용되는 값은 keep-alive와 close이다.<br><br>![](/assets/images/2024/2024-12-31-15-15-19.png)

  | **헤더**                   | **설명**                                                              |
  | -------------------------- | --------------------------------------------------------------------- |
  | **Connection: keep-alive** | 연결을 유지하여 여러 HTTP 요청을 하나의 연결에서 처리할 수 있게 한다. |
  | **Connection: close**      | 요청 후 연결을 종료하여 클라이언트와 서버 간의 연결을 끝낸다.         |

<br><br>

# 3. HTTP 요청에서 사용되는 헤더

## 3.1 Host (필수값⭐)

> 요청을 보낸 서버의 도메인 이름 또는 IP 주소와 포트 번호를 나타낸다. 이 헤더는 필수로 포함되어야 한다.

- 하나의 서버가 여러 도메인을 처리해야 할 때, 즉 하나의 IP 주소에서 여러 도메인을 운영하는 경우를 **가상 호스팅 (Virtual Hosting)**이라고 하는데, 이때 Host 헤더가 중요한 역할을 한다.
- 주로 도메인 네임 명시, 포트 번호가 포함되어 있을 수 있다. <br><br>
  ![](/assets/images/2025/2025-01-02-02-48-23.png)

<br>

> 예시: 서버가 여러 도메인을 운영하는 경우

- 예를 들어, `aaa.com`, `bbb.com`, `ccc.com` 세 도메인이 같은 서버에서 운영되고 있다고 가정해 보자.
- 이 세 도메인은 Host 헤더를 사용하여 서버가 각 도메인을 구분하고 해당하는 웹사이트의 콘텐츠를 반환할 수 있다.
- 클라이언트가 `aaa.com`을 요청하면, 요청 헤더에는 `Host: aaa.com`와 같은 Host 값이 포함된다.
- `bbb.com`을 요청하면, Host 값은 `Host: bbb.com`과 같다.<br><br>
  ![](/assets/images/2025/2025-01-02-02-52-20.png)

<br>

## 3.2 Referer

> 클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시된다.

- 즉, 사용자가 클릭한 링크나 다른 페이지에서 현재 페이지로 이동할 때, 이동하기 직전의 페이지 주소를 서버에 알려주는 역할을 한다.
- A → B로 이동하는 경우 B를 요청할 때 `Referer:A` 를 포함해서 요청한다.
- 클라이언트의 유입 경로를 파악할 수 있다.
- 참고: referer는 단어 referrer의 오타<br><br>
  ![](/assets/images/2025/2025-01-02-02-37-20.png)

<br>

## 3.3 User-Agent

> 유저 에이전트(User-Agent)란, HTTP 요청을 시작하는 클라이언트 측의 프로그램을 말한다. (e.g., 웹 브라우저 정보 등등)

- User-Agent 헤더에는 요청 메시지 생성에 관여한 클라이언트 프로그램과 관련된 다양한 정보가 명시되어있다.
- 사용자가 어떤 브라우저에서 주로 접속하는지 통계 정보를 뽑기 좋다.
- 어떤 브라우저에서 장에가 발생하는지 파악이 가능하다.<br><br>
  ![](/assets/images/2024/2024-12-31-13-16-07.png)

<br>

## 3.4 Authoriztion

> 클라이언트의 인증 정보를 서버에 전달하는 헤더

- 인증 타입(type)과 인증을 위한 정보(credentials)가 명시된다.
- 인증 타입에 따라 인증 정보에 명시될 값이 달라진다.
- 인증 방식은 Basic, token 인증 등이 존재한다. <br><br>![](/assets/images/2024/2024-12-31-13-20-04.png)

<br>

> 가장 기본적인 HTTP 인증 타입은 Basic이다.

- `username:password`를 Base64 인코딩한 값을 인증 정보로 삼는 방식이다.
- e.g., 사용자 아이디가 "sieun"이고 비밀번호가 "1234"일 경우, 인증 정보는 "sieun:1234"를 Base65 방식으로 인코딩한 "bWluY2h1bDoxMjMo"<br><br>
  ![](/assets/images/2024/2024-12-31-13-20-54.png)
  <br>

<br><br>

# 4. HTTP 응답에서 사용되는 헤더

## 4.1 Server

> 요청을 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시한다.

e.g., "Unix 운영체제에서 동작하는 아파치 HTTP 서버"를 의미하는 헤더

![](/assets/images/2024/2024-12-31-13-23-15.png)

<br>

## 4.2 Date

> HTTP 메시지가 전송된 날짜와 시간을 나타내는 헤더

- 서버가 요청을 처리한 시점의 시간 정보를 제공한다.
- 클라이언트는 이 정보를 사용해 서버의 응답이 언제 발생했는지 알 수 있다.
- 과거 스펙에는 요청에서도 사용했지만, 최신 스펙에서는 응답에서만 사용하도록 변경되었다.<br><br>
  ![](/assets/images/2024/2024-12-31-15-13-54.png)

<br>

## 4.3 Location

> 클라이언트에게 자원의 위치를 알려 주기 위해 사용되는 헤더이다.

- 웹 브라우저는 300번대 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동시킨다. (리다이렉트)
- 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 때 사용된다.
- 앞전 포스팅 HTTP 상태코드 300번대에서 설명하였다.

<br>

## 4.4 Allow

> Allow 헤더는 클라이언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용한다.

상태 코드 405(Method Not Allowed)를 응답하는 메시지에서 Allow 헤더가 함께 사용된다.

![](/assets/images/2024/2024-12-31-13-24-24.png)

<br>

## 4.5 Retry-After

> 상태 코드 503(Service Unavailable)과 함께 사용될 수 있는 헤더

- 자원을 사용할 수 있는 날짜 혹은 시각을 나타낸다.
- e.g.,
  - "2024년 8월 23일 금요일 09시 이후에 사용 가능함"(날짜 표기)
  - "120초 이후에 사용 가능함"(초단위 표기)<br><br>
    ![](/assets/images/2024/2024-12-31-13-26-00.png)

<br>

## 4.6 WWW-Authenticate

> 리소스 접근 시 필요한 인증 방법을 정의하는 헤더

상태코드 401(Unauthorized)과 함께 사용된다.

![](/assets/images/2024/2024-12-31-13-28-33.png)

<br>

> 요청 메시지의 Authorization 헤더, 응답 메시지의 WWW-Authenticate 헤더를 통한 Basic type의 HTTP 인증 과정

1. 인증되지 않은 클라이언트가 서버에 GET 요청 메시지를 전송
2. 서버는 401(Unauthorized)과 함께 WWW-Authenticate 헤더를 통해 인증 방식을 알림
3. 클라이언트는 사용자로부터 인증 정보(사용자 아이디와 비밀번호)를 전달받음
4. 클라이언트는 Base64 인코딩한 값을 Authorization 헤더를 통해 요청 메시지를 전송
5. 서버는 인증 정보를 확인
6. 인증이 유효하면 상태 코드 200으로 응답하고, 인증되지 않았으면 상태 코드 401로 응답<br><br>
   ![](/assets/images/2024/2024-12-31-13-31-45.png)

<br><br>

# 5. 전송 방식

> 전송 방식은 HTTP 헤더를 통해 데이터가 어떻게 처리될지, 어떤 방식으로 전송될지를 결정한다.

| **전송 방식** | **설명**                                               |
| ------------- | ------------------------------------------------------ |
| **단순 전송** | 데이터의 전체 크기를 정의 (Content-Length)             |
| **압축 전송** | 데이터를 압축하여 전송 (Content-Encoding)              |
| **분할 전송** | 데이터를 여러 청크로 나누어 전송 (Transfer-Encoding)   |
| **범위 전송** | 일부 데이터만 요청하고 응답받음 (Range, Content-Range) |

<br>

## 5.1 단순 전송 (Content-Length)

> Content-Length 헤더는 전송되는 데이터의 크기를 바이트 단위로 나타낸다.

- 한 번에 요청하고 한 번에 받을 수 있다.
- 클라이언트는 Content-Length 헤더를 통해 데이터를 얼마나 받을지 알 수 있다.
- 요청과 응답이 한 번에 이루어지며, 전송되는 데이터의 크기가 미리 정해져 있기 때문에, 클라이언트가 데이터를 받는 시점에 완료 여부를 쉽게 파악할 수 있다.<br><br>
  ![](/assets/images/2025/2025-01-02-02-17-31.png)

<br>

## 5.2 압축 전송 (Content-Encoding)

> Content-Encoding 헤더는 서버가 압축된 콘텐츠를 클라이언트로 전송할 때 사용된다.

- 이 헤더는 어떤 압축 방식을 사용했는지(e.g., gzip, deflate) 클라이언트에게 알려준다.
- 클라이언트는 Content-Encoding 정보를 통해 압축된 콘텐츠를 해제한 후 처리할 수 있다.<br><br>
  ![](/assets/images/2025/2025-01-02-02-17-38.png)

<br>

## 5.3 분할 전송 (Transfer-Encoding)

> Transfer-Encoding 헤더는 데이터 전송 방식을 정의하며, 청크 인코딩(Chunked encoding) 방식으로 데이터를 전송할 때 사용된다.

- 청크 인코딩을 사용할 경우, 데이터는 작은 청크로 나누어져 전송된다. 각 청크의 크기 정보와 함께 데이터가 전송된다.
- 데이터가 청크로 나누어 전송되기 때문에, 클라이언트는 데이터를 받은 즉시 처리할 수 있다.
- 분할 전송때는 content length를 넣으면 안 된다. content length를 처음에 예상할 수 없기 때문이다.<br><br>
  ![](/assets/images/2025/2025-01-02-02-18-01.png)

<br>

## 5.4 범위 전송 (Range, Content-Range)

> Range 헤더는 클라이언트가 부분적인 데이터만 요청할 때 사용된다.

예를 들어, 큰 파일을 다운로드하는 경우 전체 파일 대신 일부만 요청할 수 있다.

> Content-Range 헤더는 서버가 클라이언트의 범위 요청에 대해 응답한 부분에 대한 정보를 제공한다.

클라이언트가 Range 헤더로 일부 데이터만 요청하고, 서버는 Content-Range로 해당 범위에 대한 데이터만 응답한다.

주로 큰 파일 다운로드에서 사용된다.

![](/assets/images/2025/2025-01-02-02-18-13.png)

<br>
