---
title: "[Network] #24 캐시와 조건부 요청"
categories: [Network]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[[혼자 공부하는 네트워크↗️]](https://www.youtube.com/watch?v=c62qssA4hYI&list=PLVsNizTWUw7HfOCgvlfHIDPPo3TE-2iQM), 컴퓨터 네트워킹: 하향식 접근 (제8판)을 바탕으로 정리한 글입니다.
{: .notice--danger}

<br>

# 1. 캐시

## 1.1 캐시란?

> 캐시(cache)란, 응답 받은 자원의 **사본**을 임시 저장하는 기술을 의미한다.

- 캐시를 통해 추후 동일한 요청에 대해 캐시된 데이터를 활용할 수 있다.
- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다. (비싼 네트워크 사용량을 줄일 수 있음)
  브라우저 로딩 속도가 매우 빠르다.
- 불필요한 대역폭 낭비 방지, 응답 지연 방지, 빠른 자원 접근 가능

  | **캐시 유형**      | **설명**                                         |
  | ------------------ | ------------------------------------------------ |
  | **개인 전용 캐시** | 웹 브라우저에 저장                               |
  | **공용 캐시**      | 클라이언트와 서버 사이에 위치한 중간 서버에 저장 |

  ![](/assets/images/2025/2025-01-02-09-44-12.png)
  ![](/assets/images/2025/2025-01-02-09-46-01.png)

<br>

## 1.2 캐시 신선도의 검사와 유지

> 캐시는 자원의 **사본**을 저장한다. 즉, 캐시된 데이터는 언제든지 원본 데이터와 달라질 수 있다.

- 따라서 캐시 신선도를 고려해야한다.
- 캐시 신선도: 캐시된 사본 데이터가 얼마나 원본 데이터와 유사한지를 표현
- 그렇다면, 어떻게 캐시 신선도를 검사할 수 있을까?<br><br>
  ![](/assets/images/2024/2024-12-31-15-25-12.png)

<br>

> 캐시 신선도 검사: 유효 기간 설정

- 캐시 유효 시간이 초과하면, 서버를 통해 원본 데이터를 다시 조회하고, 캐시를 갱신한다.
- 이때 다시 네트워크 다운로드가 발생한다.<br><br>
  ![](/assets/images/2025/2025-01-02-09-48-17.png)

<br>

> 유효 기간 설정 방법

- 응답 메시지의 Expires 헤더(날짜)와 Cache-Control 헤더의 Max-Age 값(초)을 사용
- e.g., 캐시의 유효 시간을 2024년 2월 6일 화요일 12:00:00로 설정, 또는 1200초로 설정하는 응답 메시지<br><br>
  ![](/assets/images/2024/2024-12-31-15-27-49.png)

```
유효 기간이 끝났다고 가정했을 때, 새로운 데이터를 처음부터 다시 새롭게 갱신해야 할까?
그렇지 않다. 유효 기간이 끝났더라도, 서버의 원본 데이터가 변경되지 않았다면 그냥 캐시된 데이터를 사용하면 될 것이다.
```

<br><br>

# 2. 검증 헤더와 조건부 요청(1)

## 2.1 캐시 시간 초과

> 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.

1. 서버에서 기존 데이터를 변경하지 않음
2. 서버에서 기존 데이터를 변경함
   - 이 상황에서는 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있다.
   - 단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요하다. → 검증 헤더 필요<br><br>
     ![](/assets/images/2025/2025-01-02-09-53-18.png)

<br>

> 검증 헤더의 역할

검증 헤더는 클라이언트의 캐시 데이터와 서버의 데이터가 동일한지 확인하는 데 사용된다.

<br>

## 2.2 검증 헤더 추가 (캐시 신선도 재 검사)

### 2.2.1 If-Modified-Since 헤더

- 날짜를 기반으로 서버에게 물어보는 방법이다.
- If-Modified-Since 헤더에 명시된 시점 이후로 원본에 변경이 있었다면 그때만 새 자원으로 응답하도록 서버에게 요청하는 헤더이다.<br><br>
  ![](/assets/images/2025/2025-01-02-10-09-20.png)

<br>

- 아래는 "2024년 8월 23일 금요일 09:00:00 이후에 www.example.com/index.html의 자원이 변경 되었을 경우에만 새 자원으로 응답하라"는 요청 메시지이다.<br><br>
  ![](/assets/images/2024/2024-12-31-15-33-21.png)

<br>

### 2.2.2 서버의 Last-Modified 헤더

- 상태 코드 304(not Modified)를 통한 자원의 "변경 여부" 뿐만 아니라, 자원이 마지막으로 수행된 시점도 알려줄 수 있다.
- 304(not Modified)는 자원이 변경되지 않았을 경우 응답하는 상태 코드이다.
- 즉, "캐시된 데이터가 변경되지 않았으니 그대로 쓰세요" 가 304(not Modified)인 것이다.
- 아래는 2019년 10월 17일 목요일 7시 18분 26초에 변경 되었음을 알 수 있다.<br><br>
  ![](/assets/images/2024/2024-12-31-15-36-20.png)

<br>

## 2.3 검증 헤더 동작 과정

> 첫 번째 요청

1. 클라이언트가 서버로 데이터를 요청한다. (GET /star.jpg)
2. 서버는 리소스를 전송하며, 헤더에 Last-Modified 포함한다.
3. 클라이언트는 응답 데이터를 캐시에 저장한다.<br><br>
   ![](/assets/images/2025/2025-01-02-10-06-44.png)

<br>

> 두 번째 요청 (캐시 만료 후)

① 캐시 유효 시간이 초과하면 클라이언트는 기존의 Last-Modified 값을 이용해 조건부 요청을 보낸다.

![](/assets/images/2025/2025-01-02-10-11-36.png)

<br>

② 데이터가 수정되지 않은 경우 "304 Not Modified + 헤더 메타 정보" 만 응답한다.(바디X)

- 데이터의 최종 수정일이 똑같은 경우 데이터가 수정되지 않은 상태이다.
- HTTP Body는 없다. (네트워크 비용 절감)
- 클라이언트는 기존 캐시 데이터를 재사용한다.
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
- 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드한다. → 매우 실용적인 해결책<br><br>
  ![](/assets/images/2025/2025-01-02-10-20-15.png)

<br>

- 데이터가 수정된 경우
  - 상태 코드 200 OK와 함께 새 데이터를 전송한다.
  - 클라이언트는 기존 캐시를 업데이트한다.

<br><br>

# 3. 검증 헤더와 조건부 요청(2)

## 3.1 검증 헤더의 역할

> 검증 헤더의 역할

검증 헤더는 클라이언트의 캐시 데이터와 서버 데이터가 동일한지 확인하는 데 사용된다.

<br>

> 검증 헤더의 종류

크게 Last-Modified와 ETag로 구분된다.<br><br>
| **조건부 요청/응답 헤더** | **설명** |
|-------------------------------|----------------------------------------------------------|
| **Last-Modified / If-Modified-Since** | 데이터의 최종 수정 시각을 기준으로 요청/응답 |
| **ETag / If-None-Match** | 데이터를 식별할 고유 태그를 기반으로 요청/응답 |

<br>

> 조건부 요청 헤더

- 서버 데이터의 변경 여부에 따라 조건부로 응답을 전송한다.
  - 200 OK: 데이터 변경(HTTP Body 포함)
  - 304 Not Modified: 데이터 미변경(HTTP Body 제외)

<br>

## 3.2 Last-Modified와 If-Modified-Since의 한계

- 1초 미만 단위 캐시로 캐시 조정이 불가능
- 날짜 기반 로직이므로 세밀한 캐시 관리가 어렵다.
  - 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 결과가 똑같은 경우에도 전체 데이터를 다 다시 다운로드 한다.
- 서버에서 별도의 캐시 로직을 적용하기 힘들다.
  - e.g., 주석, 공백 등 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우 캐시 메커니즘을 컨트롤하기 힘들다.

<br>

## 3.3 ETag와 If-None-Match 헤더

서버에서 캐시 메커니즘을 컨트롤 할 수 있는 방법이다.

<br>

## 3.3.1 ETag (Entity Tag)

데이터를 식별하는 고유한 버전 이름.
서버에서 데이터를 변경하면 새로운 ETag 생성.
예:
vbnet
코드 복사

<br>

### 2.2.2 If-None-Match 헤더

- 엔티티 태그(Etag)를 기반으로 서버에게 물어보는 방법이다.
- Etag는 "자원의 버전"을 식별하기 위한 정보이다.
  - 버전이란 "유의미한 변경 사항"을 의미한다.
  - 캐시용 데이터에 임의의 고유한 버전을 달아둔다,
  - 즉, 데이터가 변경될 때마다 자원의 버전을 식별하는 Etag 값이 변경된다. (Hash를 다시 생성)
  - 반대로 자원이 변경되지 않았았다면 Etag 값도 변경되지 않는다.<br><br>
    ![](/assets/images/2024/2024-12-31-15-42-39.png)

진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기

<br>

- 따라서 클라이언트는 Etag 값과 일치하는 자원이 있니? 라고 서버에게 물어봄으로써 변경사항이 있는지 확인할 수 있다.
- 아래는 "Etag 값이 abc인 www.example.com/index.html이라는 자원이 있니? 자원이 변경되었다면(Etag 값이 바뀌었다면) 그때만 새 자원으로 응답해줘" 라는 메시지이다.<br><br>
  ![](/assets/images/2024/2024-12-31-15-44-27.png)
