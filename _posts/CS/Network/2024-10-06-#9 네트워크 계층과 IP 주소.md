---
title: "[Network] #9 네트워크 계층과 IP 주소"
categories: [Network]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[[혼자 공부하는 네트워크↗️]](https://www.youtube.com/watch?v=c62qssA4hYI&list=PLYH7OjNUOWLVwdRF6_QmJVR4cQdMp0SU1&index=1), 컴퓨터 네트워킹: 하향식 접근 (제8판)을 바탕으로 정리한 글입니다.
{: .notice--danger}

- 지난 포스팅에서 같은 네트워크 내에 호스트끼리 정보를 주고 받기 위해 케이블, 허브, 스위치 같은 장비를 학습했다.
- 이번 포스팅에는 **LAN을 넘어 다른 네트워크와 속한 호스트와 패킷을 주고받을 수 있게** 하는 "네트워크 계층"에 대해 학습해보자.

---

<br>

# 1. 물리 계층과 데이터링크 계층의 한계

> 물리 계층과 데이터 링크 계층만으로는 LAN을 넘어서 통신하기 어려운데, 그 이유는 아래와 같다.

① 다른 네트워크까지의 도달 경로를 파악하기 어렵다.

- 지구 반대편에 있는 친구와 패킷을 주고받는다고 가정하자. 이 경우는 네트워크 간 통신이 이루어지기 때문에 패킷이 여러 네트워크를 거쳐 이동할 것이다.
- 이때, 패킷이 어떤 경로로 이동해야 최적인지를 물리 계층과 데이터링크 계층의 기술 만으로는 판단하기 어렵다.
- 따라서 네트워크 계층의 <span style="color:indianred">라우팅(routing)</span>으로 패킷이 이동할 최적의 경로를 결정해야 한다.
- 라우터(router)는 라우팅을 수행하는 대표적인 장비를 의미한다.<br><br>
  ![](/assets/images/2024/2024-10-06-15-01-39.png)

<br>

② 모든 네트워크에 속한 모든 호스트의 위치를 특정하기 어렵다.

- MAC 주소는 기본적으로 네트워크 인터페이스마다 부여가 되는데, 호스트는 시시때때로 속해있는 네트워크가 얼마든지 달라질 수도 있기 때문에, MAC 주소 하나만으로 모든 네트워크에 속한 모든 호스트의 위치를 특정하기 어렵다.
  - e.g., 집에서 Wi-Fi를 사용하다가 회사에서는 셀룰러 데이터를 사용 -> 집의 네트워크에서 사용하던 MAC 주소는 회사 네트워크에선 더 이상 유효하지 않음.
- 이러한 MAC 주소의 한계(로컬 네트워크 내에서만 유효)를 극복하기 위해 사용되는 네트워크 주소 체계를 <span style="color:indianred">IP 주소</span>라고 한다.
- MAC 주소와 IP 주소는 함께 사용되고, 기본적으로 IP 주소를 우선 활용한다.

|           MAC 주소           |                            IP 주소                             |
| :--------------------------: | :------------------------------------------------------------: |
|    택배의 **수신인** 역할    |                     택배의 **수신지** 역할                     |
|          물리 주소           |                           논리 주소                            |
| NIC마다 할당되는 고정된 주소 | - 유동적으로 할당<br>- 자동으로 할당 받거나 사용자가 직접 할당 |

![](/assets/images/2024/2024-10-06-15-06-12.png)

<br><br>

# 2. 네트워크 계층의 핵심, IP

> 물리 계층과 데이터 링크 계층의 한계를 극복하는 프로토콜이다.

IP 프로토콜은 주소 지정(IP addressing), 단편화(IP fragmentation)의 기능을 제공한다.

## 2.1 주소 지정

> 주소 지정이란, IP 주소(IPv4)를 바탕으로 송수신 대상을 지정하는 것을 의미한다.

- <span style="color:indianred">4바이트(32비트)</span>로 하나의 주소를 표현한다. `192.168.1.1`
- 즉, `2^32`만큼 (약 43억)표현이 가능하다.
- 숫자당 8비트씩(2^8) 끝어서 표시되며, 0~255 범위 안에 있는 네 개의 10진수로 표기한다.
- 8비트로 표현할 수 있는 값의 범위는 00000000(0)부터 11111111(255)까지이다.
- 각각의 숫자는 점(.)으로 구분하는데, 이 점으로 구분된 각각의 숫자를 옥텟(octet)이라고 한다.

<br>

## 2.2 단편화

> 단편화란, 전송하고자 하는 패킷의 크기를 **MTU** 이하의 복수의 패킷으로 나눈 것을 의미한다.

- MTU(Maximum Transmission Unit)란?

  - 한 번에 전송 가능한 IP 패킷의 최대 크기를 의미한다.
  - IP 패킷의 헤더도 MTU 크기에 포함된다.
  - 일반적으로 MTU 크기는 **1500바이트**이며, MTU 크기 이하로 나누어진 패킷은 수신지에 도착하면 다시 재조합된다.

  ![](/assets/images/2024/2024-10-06-17-18-32.png)

<br>

> 이더넷 프레임에서 페이로드에 명시할 수 있는 일반적인 데이터 크기는 1500바이트로 제한되어 있는 이유는, 데이터 부분의 `IPv4 패킷 헤더 + IPv4 패킷 페이로드` 보다 커지면 단편화가 이루어지기 때문이다.

아래 그림의 데이터 부분(IPv4 패킷 헤더 + IPv4 패킷 페이로드)이 IPv4의 패킷 구조이다.

![](/assets/images/2024/2024-10-06-17-23-24.png)

<br>

## 2.3 IPv4 패킷의 핵심 필드

> IPv4 패킷의 핵심 필드는 1)식별자, 2)플래그, 3)단편화 오프셋, 4)TTL, 5)프로토콜, 6)송신지 IP 주소, 7)수신지 IP 주소 가 존재한다.

- 1)식별자, 2)플래그, 3)단편화 오프셋 필드를 기준으로 **단편화**가 이루어진다.
- 6)송신지 IP 주소, 7)수신지 IP 주소 필드를 기준으로 **주소 지정**이 이루어진다.

![](/assets/images/2024/2024-10-06-17-25-22.png)

<br>

### 2.3.1 식별자(identifier)

> 패킷에 할당된 고유한 번호가 명시가 된다.

쪼개져서 도착한 IPv4 패킷들이 **어떤 메시지에서 쪼개졌는지**를 알기 위해 사용된다.

![](/assets/images/2024/2024-10-06-17-26-58.png)

<br>

### 2.3.2 플래그(flag)

> 세 개의 비트로 구성되어 있는 필드를 말한다.

- 첫 번째 비트는 항상 0으로써 현재 사용되지 않으며, 실질적으로 사용되는 비트는 아래와 같다.
- DF 비트(Don't Fragment): IP 단편화 수행여부를 나타냄
  - 1이라면: IP 단편화 수행하지 말것
  - 0이라면: IP 단편화 가능하다
- MF 비트(More Fragment): 단편화된 패킷이 더 있는지를 나타냄
  - 1이라면: 쪼개진 패킷이 아직 더 있다.
  - 0이라면: 이 패킷이 마지막 패킷이다

![](/assets/images/2024/2024-10-06-17-28-45.png)

<br>

### 2.3.3 단편화 오프셋(fragment offset)

> 초기 데이터에서 몇 번째로 떨어진 패킷인지를 나타내는 필드를 말한다.

- 단편화되어 전송되는 패킷들은 수신지에 순서대로 도착하지 않을 수 있다.
- 수신지가 패킷들을 순서대로 재조합하려면 단편화된 패킷이 **초기 데이터에서 몇 번째에 해당하는 패킷**인지 알아야 한다.

![](/assets/images/2024/2024-10-06-17-34-32.png)

<br>

### 2.3.4 TTL(Time to Live)

> 패킷의 수명을 나타내는 필드를 말한다.

- 무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지하기 위해 존재한다.
- 패킷(데이터그램)이 하나의 라우터를 거칠 때마다 TTL 값이 1씩 감소하며, TTL이 0이 되면 폐기된다.
- 홉(hop): 패킷이 호스트 또는 라우터에 한 번 전달되는 것을 말한다.
  - 즉, TTL 필드는 홉마다 1씩 감소되는 값이라고 볼 수 있다.

![](/assets/images/2024/2024-10-06-18-11-14.png)

<br>

### 2.3.5 헤더 체크섬

> 헤더 체크섬은 IP 데이터그램의 헤더 오류 검출에 사용되며, 라우터는 오류가 발견된 데이터그램을 폐기한다.

- TTL 및 옵션 필드는 각 라우터에서 변경되므로, 체크섬은 매번 재계산되어야 한다.
- 네트워크 계층(IP)과 전송 계층(TCP/UDP)에서 각각 오류 검사를 수행하는 이유는:
  - IP 계층은 헤더만 검사(데이터는 제외)하고,
  - TCP/UDP 체크섬은 전체 세그먼트(헤더와 데이터)를 검사한다.
  - TCP/UDP는 IP 프로토콜에 의존하지 않아서, IP가 아닌 다른 프로토콜 위에서도 동작할 수 있다.
    <br>

### 2.3.6 프로토콜

> 상위 계층의 프로토콜이 무엇인지를 나타내는 필드이다.

- 이 필드는 일반적으로 IP 데이터그램이 최종 목적지에 도착했을 때만 사용된다.
- 무엇을 캡슐화했는지를 프로토콜 필드에 명시한다.
- e.g., 전송 계층의 대표적인 프로토콜인 TCP는 6번, UDP는 17번

<br>

### 2.3.6 송/수신지 IP 주소

> 이름 그대로 송/수신지의 IPv4 주소를 의미한다.

<br><br>

# 3. IPv6

## 3.1 IPv6이란?

> IP 패킷의 헤더에는 송신지 IP 주소와 수신지 IP 주소를 명시할 수 있다! 하나의 IP주소는 32bit로 표현이 된다. 그럼 이론적으로 할당 가능한 IPv4 주소는 몇 개일까?

- 이론적으로 할당 가능한 IPv4 주소는, 총 `2^32개`로 약 43억 개이다.
- 하지만, 전 세계 인구가 하나씩 IP 주소를 가지고 있어도 부족한 숫자이다.
- 결국 약 43억 개라는 IPv4의 주소의 총량은 쉽게 고갈된다.

<br>

> 이런 IP 주소 부족 문제를 해결하기 위해 등장한 프로토콜이 IPv6이다.

- IPv6는 <span style="color:indianred">16바이트(128비트)</span>로 주소를 표현할 수 있고, 콜론(:)으로 구분된 8개 그룹의 16진수로 표기된다.
- 이론적으로 할당 가능한 IPv6 주소는 2^128개이다. (사실상 무한에 가까운 수 할당 가능)
- IPv4 주소 표기: `192.168.1.1`
- IPv6 주소 표기: `2001:0230:abcd:ffff:0000:0000:ffff:1111`

<br>

## 3.2 IPv6 패킷의 핵심 필드

> IPv6 패킷의 핵심 필드는 1)다음 헤더, 2)홉 제한, 3)송신지 IP 주소, 4)수신지 IP 주소 가 존재한다.

![](/assets/images/2024/2024-10-06-18-24-47.png)

<br>

### 3.2.1 다음 헤더(next header)

> 상위 계층의 프로토콜 또는 확장 헤더를 가리키는 필드이다.

- 확장 헤더란?
  - IPv6는 기본 헤더와 더불어 확장 헤더라는 추가 헤더를 가질 수 있다.
  - 확장 헤더는 기본 헤더와 페이로드 데이터 사이에 위치한다.
  - 마치 꼬리를 물듯 또 다른 확장 헤더를 가질 수 있다.

![](/assets/images/2024/2024-10-06-18-26-50.png)
![](/assets/images/2024/2024-10-06-18-27-56.png)

<br>

- 대표적인 확장 헤더
  - 홉 간 옵션
  - 수신지 옵션
  - 라우팅
  - **단편**
  - ESP
  - ...

여기서 IPv6의 단편화와 깊이 연관되어있는 단편 헤더에 대해 자세히 살펴보도록 하자.

<br>

### 3.2.2 IPv6의 단편화

> IPv6는 단편화 확장 헤더를 통해 단편화가 이루어진다.

- 단편화 확장 헤더에도 다음 헤더 필드가 존재한다.
- 예약됨(reserved)과 예약(res) 필드는 0으로 설정되어 사용되지 않는다.
- 단편화 오프셋과 M 플래그, 식별자 필드를 갖는다.
  - 단편화 오프셋: 전체 메시지에서 현재 단편화된 패킷의 위치(IPv4의 단편화 오프셋 필드와 유사)
  - M 플래그: 1일 경우 더 많은 단편화 패킷이 있음을, 0일 경우 마지막 패킷을 의미(IPv4의 MF 플래그 필드와 유사)
  - 식별자: 동일한 메시지에서부터 단편화된 패킷임을 식별(IPv4의 식별자 필드와 유사)

![](/assets/images/2024/2024-10-06-18-30-38.png)

<br>

### 3.2.3 홉 제한(hop limit)

> 패킷의 수명을 나타내는 필드이다.

IPv4 패킷의 TTL 필드와 비슷하다.

<br>

### 3.2.4 송신지 IP 주소, 수신지 IP 주소

> IPv6 주소를 통한 송수신지를 지정하는 필드이다.

<br><br>

# 4. IP 단편화를 피하는 방법

> IP 단편화는 되도록 하지 않는 것이 좋다. 그 이유는 다음과 같다.

1. 불필요한 트래픽 증가와 대역폭 낭비
2. 쪼개진 IP 패킷들을 하나로 합치는 과정에서 발생하는 부하도 성능 저하 요소<br><br>
   ![](/assets/images/2024/2024-10-06-22-35-41.png)

<br>

> IP 단편화를 피하려면?

- IP 패킷을 주고받는 모든 노드가 "**IP 단편화 없이 주고 받을 수 있는 최대 크기**" 만큼만 전송해야 한다.
- 이때, IP 단편화 없이 주고 받을 수 있는 최대 크기를 **경로 MTU(Path MTU)** 라고 부른다.
- 즉, 단편화를 피하는 방법은 Path MTU 만큼의 데이터를 전송하는 것이다.
- path MTU discovery(경로 MTU 발견): 경로 MTU를 구하고 해당 크기만큼 송수신하여 IP 단편화를 회피하는 기법을 의미한다.<br><br>
  ![](/assets/images/2024/2024-10-06-22-25-41.png)

<br>

> 실제로도 단편화는 자주 일어나지 않는다.

대부분 DF(Don't Fragment) 비트가 세팅되어 있기 때문이다.

![](/assets/images/2024/2024-10-06-22-36-24.png)

<br><br>

# 5. IP 주소의 구조와 클래스풀 주소 체계

## 5.1 IP 주소의 구조

> 위에서 설명했다 싶이, IP 핵심 기능 중 하나인 "주소 지정"은 IP주소로 이루어졌다. 그렇다면 IP 주소의 구조는 어떻게 구성되는지 살펴보자.

- IP 주소의 구조는 크게 **네트워크 주소**와 **호스트 주소**로 구성된다.

  - 네트워크 주소(=네트워크 ID, =네트워크 식별자): 네트워크를 표현하는 부분이며, 호스트가 속한 특정 네트워크를 식별한다.
  - 호스트 주소(=호스트 ID, =호스트 식별자): 호스트를 표현하는 부분이며, 특정 호스트를 식별한다.<br><br>
    ![](/assets/images/2024/2024-10-06-22-43-06.png)

<br>

> IP 주소에서 네트워크 주소와 호스트 주소 크기는 각각 어느 정도가 적당할까?

그때그때 다르다! 네트워크 주소에 상대적으로 많은 비트를 할당할 수도 있고, 적은 비트를 할당할 수도 있기 때문이다.

- 아래 그림처럼 호스트 주소가 큰 경우, 한 네트워크당 호스트 할당에 24비트를 사용할 수 있다.
- 즉, 상대적으로 많은 호스트에 IP 주소를 할당할 수 있다.<br><br>
  ![](/assets/images/2024/2024-10-06-22-46-25.png)

<br>

- 아래 그림처럼 네트워크 주소가 큰 경우, 한 네트워크당 호스트 할당에 8비트를 사용할 수 있다.
- 즉, 상대적으로 적은 호스트에 IP 주소를 할당할 수 있다.<br><br>
  ![](/assets/images/2024/2024-10-06-22-52-25.png)

<br>

- 무조건 호스트 주소 공간을 크게 할당하면?
  - 호스트가 할당되지 않은 다수의 IP 주소가 낭비된다.
- 무조건 호스트 주소 공간을 작게 할당하면?
  - 호스트가 사용할 IP 주소가 부족해진다.<br><br>

즉, 이런 고민을 해결하기 위해 **IP 주소의 클래스(class)** 라는 개념이 도입되었다.

<br>

## 5.2 클래스풀 주소 체계

> **클래스**란 네트워크 크기에 따라 IP 주소를 분류하는 기준을 의미하며, **클래스풀 주소 체계**(classful addressing)란 클래스를 기반으로 IP 주소를 관리하는 주소 체계를 의미한다.

총 5개의 클래스가 존재한다.

- IP 주소 지정에 사용되는 실질적인 클래스는 A클래스, B클래스, C클래스이다.
  - A, B, C 클래스는 네트워크 옥텟을 각각 1, 2, 3 옥탯으로 표현한다.
- 각 클래스마다 네트워크 주소를 표현하는 크기가 다르기 때문에, 필요한 호스트 IP 개수에 따라 클래스를 달리 선택하여 네트워크 크기를 조정할 수 있다.<br><br>
  ![](/assets/images/2024/2024-10-06-22-57-33.png)

<br>

## 5.3 A클래스

> B와 C클래스에 비에 할당 가능한 주소의 수가 많다. (큰 네트워크, 수백만 대의 기기를 연결할 수 있음)

- 네트워크 주소는 **비트 0**으로 시작하는 1옥텟, 호스트 주소는 3옥텟으로 구성된다.
- 이론상 `2^7`개의 A 클래스 네트워크가 존재 가능하다.
- 각 네트워크에 `2^24`개의 호스트 주소 할당이 가능하다.<br><br>
  ![](/assets/images/2024/2024-10-06-23-02-41.png)

<br>

> A클래스로 나타낼 수 있는 IP 주소 범위

- 최솟값을 10진수로 표현하면 `0.0.0.0`
- 최댓값을 10진수로 표현하면 `127.255.255.255`

즉, 가장 처음 옥텟의 주소가 `0~127`일 경우 A클래스 주소임을 짐작할 수 있다.

![](/assets/images/2024/2024-10-06-23-05-07.png)

<br>

## 5.4 B클래스

> B클래스의 네트워크 주소는 **비트 10으로 시작**하는 2옥텟, 호스트 주소도 2옥텟으로 구성되어있다. (중간 크기의 네트워크)

이론상 `2^14`개의 B클래스 네트워크가 존재 가능하며, 각 네트워크에 `2^16`개의 호스트 주소를 할당할 수 있다.

![](/assets/images/2024/2024-10-06-23-08-03.png)

<br>

> B클래스로 나타낼 수 있는 IP 주소 범위

- 최솟값을 10진수로 표현하면 `128.0.0.0`
- 최댓값을 10진수로 표현하면 `191.255.255.255`

즉, 가장 처음 옥텟의 주소가 `128~191`일 경우 B클래스 주소임을 짐작할 수 있다.

![](/assets/images/2024/2024-10-06-23-10-22.png)

<br>

## 5.4 C클래스

> C클래스의 네트워크 주소는 **비트 110으로** 시작하는 3옥텟, 호스트 주소는 1옥텟으로 구성되어있다. (작은 네트워크, 수백 대 정도의 기기를 연결)

이론상 `2^21`개의 C클래스 네트워크가 존재 가능하며, 각 네트워크에 `2^8`개의 호스트 주소를 할당할 수 있다.

![](/assets/images/2024/2024-10-06-23-12-53.png)

<br>

> C클래스로 나타낼 수 있는 IP 주소 범위

- 최솟값을 10진수로 표현하면 `192.0.0.0`
- 최댓값을 10진수로 표현하면 `223.255.255.255`

즉, 가장 처음 옥텟의 주소가 `192~223`일 경우 C클래스 주소임을 짐작할 수 있다.

![](/assets/images/2024/2024-10-06-23-13-32.png)

<br>

## 5.5 주소 체계의 예외

> 호스트의 주소 공간을 모두 사용할 수 있는 것은 아니다.

- 호스트 주소가 전부 0인 IP 주소
  - 해당 네트워크 자체를 의미하는 **네트워크 주소**로 사용된다.
- 호스트 주소가 전부 1인 IP 주소
  - **브로드캐스트 주소**로 사용된다.<br><br>
    ![](/assets/images/2024/2024-10-06-23-15-17.png)

<br>

## 5.6 클래스별 할당 가능한 주소의 개수 정리

> 클래스별 할당 가능한 주소의 개수는 `-2`를 뺀 수와 같다.

![](/assets/images/2024/2024-10-06-23-16-48.png)

<br>

## 5.7 클래스풀 주소 체계의 한계

> 클래스별 네트워크 크기가 고정되어 있어 여전히 낭비되는 IP 주소가 많을 수 있다.

- A클래스 네트워크 하나 당 할당 가능한 호스트: 1600만개 이상
- B클래스 네트워크 하나 당 할당 가능한 호스트: 6만개 이상

이 IP를 모두 쓰지는 않을 것이다.

![](/assets/images/2024/2024-10-06-23-22-09.png)

<br>

> 그리고 클래스별 네트워크 크기가 고정되어 있어 사전에 정해진 크기 외의 다른 네트워크 구성이 불가능하다.

- C클래스 네트워크 하나 당 할당 가능한 호스트: 254개
- 만약, 직원 300명 컴퓨터를 동일 네트워크로 구성하려면 B클래스 주소를 이용해야 할까?<br><br>
  ![](/assets/images/2024/2024-10-06-23-23-38.png)

<br>

이러한 클래스풀 주소 체계의 한계를 보완하기 위해 "클래스리스 주소 체계" 방식을 주로 사용한다.

<br><br>

# 6. 클래스리스 주소 체계

## 6.1 클래스리스 주소 체계란?

> 클래스 리스 주소 체계란(classless addressing), 클래스 개념 없이(classless) **클래스에 구애받지 않고** 네트워크 영역을 나누고 호스트에게 IP 주소 공간을 할당하는 방식이다.

- 클래스풀 주소 체계는 A, B, C 클래스처럼 고정된 크기의 네트워크 주소 범위를 사용했지만, 클래스리스 주소 체계에서는 네트워크 크기를 더 자유롭게 조정할 수 있다.
- 오늘날 주로 활용되는 방식이다.

그렇다면 클래스에 구애받지 않고 어떻게 정교하게 네트워크 크기를 나눌 수 있는지 살펴보자.

<br>

## 6.2 서브넷 마스크

> 서브넷 마스크(subnet mask)란, 클래스 없이 IP 주소의 네트워크 주소, 호스트 주소를 구분할 수 있는 수단으로, IP 주소상에서 네트워크 주소는 1, 호스트 주소는 0으로 표기한 비트열을 의미한다.

"서브넷"이라는 이름 자체가 부분적인 네트워크(서브 네트워크)를 의미하기 때문에, "네트워크 주소와 호스트 주소를 구분하는 비트 열" 이라고 해석하기도 한다.

<br>

> A, B, C 클래스의 기본 서브넷 마스크

- A클래스: 255.0.0.0 (11111111.00000000.00000000.00000000)
- B클래스: 255.255.0.0 (11111111.11111111.00000000.00000000)
- C클래스: 255.255.255.0 (11111111.11111111.11111111.00000000)

<br>

## 6.3 서브네팅

> 서브네팅(subnetting)이란, 서브넷 마스크를 이용해 클래스를 원하는 크기로 더 잘게 쪼개어 사용하는 것을 의미한다.

- 이렇게 나누면 각 서브넷마다 고유한 네트워크 주소와 호스트 주소 범위를 설정할 수 있다.
- 서브넷 마스크로 네트워크 주소와 호스트 주소를 구분 짓는 방법에 대해 알아보자

  1. IP 주소와 서브넷 마스크가 주어졌을 때, 두 값을 이진수로 변환한다.
  2. 그 후, 비트 AND 연산을 통해 네트워크 주소를 구하면 된다.<br><br>
     ![](/assets/images/2024/2024-10-06-23-38-25.png)

<br>

> 네트워크 주소를 구해보자!

① 아래와 같은 IP 주소와 서브넷 마스크가 있다고 가정

![](/assets/images/2024/2024-10-06-23-40-26.png)

<br>

② IP 주소와 서브넷 마스크를 2진수로 변환

![](/assets/images/2024/2024-10-06-23-40-34.png)

③ IP 주소와 서브넷 마스크를 비트 AND 연산

<br>

![](/assets/images/2024/2024-10-06-23-41-01.png)

④ 즉, 할당 가능한 호스트 IP 주소의 범위는 아래와 같다.

- 호스트 주소 모두 0: 네트워크 주소: `192.168.219.0`
- 호스트 주소 모두 1: 브로드 캐스트 주소: `192.168.219.255`
- 호스트 할당 가능 IP 주소: `192.168.219.1` ~ `192.168.219.254`

<br>

## 6.4 서브넷 마스크 표기: CIDR 표기법

> 서브넷 마스크를 표기할 때 `255.255.255.0`과 같이 10진수로 직접 표기하는 경우도 있지만, "IP 주소/서브넷 마스크상의 1의 개수 형식"으로 표기하는 경우도 많다. 이를 CIDR(Classless Inter-Domain Routing) 표기법이라고 한다.

e.g., C클래스의 기본 서브넷 마스크는 `255.255.255.0`, 이를 2진수로 표기하면 `11111111.11111111.11111111.00000000`(1이 총 24개) -> 따라서 `/24`

![](/assets/images/2024/2024-10-07-00-38-57.png)

<br>

> (복습) `192.168.02/25`는 어떤 네트워크에 속한 어떤 호스트를 가르킬까?

① 네트워크와 호스트 주소 계산

- IP 주소를 나타내는 192.168.0.2를 2진수로 표현하면 `11000000.10101000.00000000.00000010`이다.
- 서브넷 마스크를 나타내는 `/25`는 1이 총 25개 `11111111.11111111.11111111.10000000`을 의미한다.
- 이를 10진수로 표현하면 `255.255.255.128`이다.<br><br>
  ![](/assets/images/2024/2024-10-07-00-42-05.png)

<br>

② 서브넷 마스크를 IP주소 `192.168.0.2`와 비트 AND 연산

- 결과는 `192.168.0.0` -> 즉, 네트워크 주소는 `192.168.0.0`이다.
- 호스트는 7비트로 표현할 수 있다.<br><br>
  ![](/assets/images/2024/2024-10-07-00-48-07.png)

<br>

③ 즉, 할당 가능한 호스트 IP 주소의 범위는 아래와 같다.

- 네트워크 주소: `192.168.0.0`
- 브로드캐스트 주소: `192.168.0.127`
- 할당 가능 호스트 IP 주소: `192.168.0.126`

<br>

④ 따라서, `192.168.0.2/25`는 총 126개의 호스트를 할당할 수 있는 `192.168.0.0`이라는 네트워크에 속한 `192.168.0.2`를 의미한다.

<br>
