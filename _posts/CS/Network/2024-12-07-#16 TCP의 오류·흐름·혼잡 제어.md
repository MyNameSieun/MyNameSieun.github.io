---
title: "[Network] #16 TCP의 오류·흐름·혼잡 제어"
categories: [Network]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[[혼자 공부하는 네트워크↗️]](https://www.youtube.com/watch?v=c62qssA4hYI&list=PLVsNizTWUw7HfOCgvlfHIDPPo3TE-2iQM), 컴퓨터 네트워킹: 하향식 접근 (제8판)을 바탕으로 정리한 글입니다.
{: .notice--danger}

- 지난 포스팅에서 TCP에 대해서 알아봤다.
- 이번 포스팅에서는 TCP가 신뢰성 있는 통신을 위해 어떤 기능을 제공하는 지에 대해 알아보도록 하자.

---

<br>

# 1. TCP의 기능

# 1.1 TCP의 오류·흐름·혼잡 제어

앞선 포스팅에서 살펴봤던 것처럼 TCP(Transmission Control Protocol)는 신뢰성 있는 데이터 전송을 보장하는 연결형 프로토콜이다.

![](/assets/images/2024/2024-12-07-19-36-38.png)

<br>

- TCP는 데이터를 송수신 할 때 신뢰성있는 전송을 보장하기 위해 "재전송을 위한 오류 제어", "흐름 제어", "혼잡 제어" 와 같은 기능을 제공한다.
  - 오류 제어: 송수신된 데이터가 손상되거나 유실된 경우, 이를 감지하고 재전송하여 데이터의 정확성을 보장
  - 흐름 제어: 송신자가 수신자가 처리할 수 있는 양을 초과하여 데이터를 전송하지 않도록 하여 수신자의 버퍼 오버플로우를 방지
  - 혼잡 제어: 네트워크의 혼잡 상태를 감지하고, 혼잡 상황에 따라 데이터 전송 속도를 조절하여 네트워크 과부하를 방지

<br><br>

# 2. 재전송 기반 오류 제어

## 2.1 오류 제어의 필요성

```
TCP 세그먼트 헤더와 UDP 데이터그램 헤더에는 오류 검출을 하는 체크섬 필드로 오류 제어를 하면 되는 것 아닌가?
```

체크섬 필드로만 오류 제어를 하기엔 충분하지 않다. 체크섬 필드는 데이터가 훼손되었는지의 여부만 나타내기 때문이다.

해당 패킷 자체가 유실되거나 잘못 전송되거나 순서에 어긋나게 전송되었을 경우 체크섬 필드만으로는 오류를 검출하기 어려울 것이다.

<br>

> 그렇기 때문에 TCP가 신뢰성을 제대로 보장하려면:

- 송신 호스트가 송신한 세그먼트가 정상적으로 도달했는지 확인하고,
- 오류를 감지하게 되면 해당 세그먼트를 재전송 할 수 있어야 한다.

<br>

## 2.2 오류 검출 시점

> TCP는 언제 오류를 검출하고 재전송할까?

① 중복된 ACK 세그먼트를 수신했을 때

- 수신자가 이미 수신한 세그먼트를 다시 ACK(승인 응답)하면, 송신자는 해당 세그먼트가 유실되었거나 오류가 발생했음을 인지하고 재전송을 시작한다.<br>

  ![](/assets/images/2024/2024-12-07-22-04-15.png)

<br>

② 타임아웃이 발생했을 때

- 송신자는 각 세그먼트를 전송할 때마다 타이머를 설정한다.
- 만약 타이머가 만료될 때까지 ACK 세그먼트를 받지 못하면, 송신자는 해당 세그먼트를 재전송한다.<br><br>
  ![](/assets/images/2024/2024-12-07-22-06-09.png)

<br>

## 2.3 재전송 기법: ARQ

> ARQ(Automatic Repeat Request, 자동 재전송 요구)

- ARQ(Automatic Repeat Request)는 수신자의 ACK 응답과 송신자의 타임아웃을 기반으로 오류가 발생한 경우 데이터를 재전송하는 방식이다.
- ARQ의 주요 목적은 신뢰성 있는 데이터 전송을 보장하는 것이다.

<br>

> ARQ의 대표적인 세 가지 방식

- Stop-and-Wait ARQ
- Go-Back-N ARQ
- Selective Repeat ARQ<br><br>
  ![](/assets/images/2024/2024-12-07-22-11-22.png)

<br>

### 2.1.1 Stop-and-Wait ARQ

> 제대로 전달했음을 확인하기 전까지는 새로운 메시지를 보내지 않는 방식 ("송신하고, 확인받고, 송신하고, 확인받고, ...")

- 송신자는 각 세그먼트에 대해 수신자로부터 ACK를 받을 때까지 다음 세그먼트를 보내지 않는다.
- 장점: 단순하지만, 높은 신뢰성을 보장한다.
- 단점: 네트워크의 이용 효율이 낮아지고 성능이 저하된다.

<br>

- 송신 호스트(A): 확인 응답을 받기 전에는 더 보내고 싶어도 못 보냄
- 수신 호스트(B): 더 많은 데이터를 처리할 수 있어도 하나씩만 확인 응답<br><br>
  ![](/assets/images/2024/2024-12-07-23-30-03.png)

<br>

> Stop-and-Wait ARQ의 문제 해결 방법: 파이프라이닝

- 각 세그먼트에 대한 ACK 세그먼트가 도착하기 전이더라도 여러 세그먼트를 보낼 수 있어야 함
- 파이프라이닝
  - 연속해서 메시지를 전송할 수 있는 기술
  - n+1에 대한 확인 응답이 오기 전이라도 연속해서 데이터를 보낼 수 있음<br><br>
    ![](/assets/images/2024/2024-12-07-23-31-28.png)

<br>

### 2.1.2 Go-Back-N ARQ

> 파이프라이닝 기반 ARQ 일종으로, 여러 세그먼트 전송 중 오류가 발생하면 해당 세그먼트부터 전부 재전송

순서번호 n번에 대한 ACK 세그먼트는 "n번만의" 확인 응답이 아닌 "n번까지의 누적 확인 응답 (CACK; Cumulative Cumulative Acknowledgment)"

![](/assets/images/2024/2024-12-07-23-33-48.png)

<br>

### 2.1.3 Selective Repeat ARQ

> 손실된 세그먼트만을 선택적으로 재전송하는 방식

- 각각의 패킷들에 대해 ACK 세그먼트를 보냄
- Go-Back-N ARQ의 ACK 세그먼트가 **누적 확인 응답** 이라면,
- Selective Repeat ARQ의 ACK 세그먼트는 **개별 확인 응답**<br><br>
  ![](/assets/images/2024/2024-12-08-00-00-29.png)

<br>

- 오늘날 대부분의 호스트는 Selective Repeat ARQ를 지원한다.
- Selective Repeat ARQ를 사용하지 않을 경우, Go-Back-N ARQ로 동작한다.

<br><br>

# 3. 흐름 제어

## 3.1 파이프라이닝 데이터 전송의 한계

```
파이프라이닝의 송수신이 한 번에 무한히 많이 데이터를 보내고 받을 수 있을까?
```

그렇지 않다. 한 번에 송수신 할 수 있는 양이 호스트마다 정해져 있다.

![](/assets/images/2024/2024-12-08-00-02-02.png)

<br>

- 파이프라이닝 기반 Go-Back-N ARQ / Selective Repeat ARQ가 정상 동작하려면
  - 수신 호스트가 한 번에 얼마나 받아 처리할 수 있는지 반드시 고려해야 한다.
  - 호스트가 한 번에 받아서 처리할 수 있는 세그먼트의 양에는 한계가 있기 때문이다.
  - 수신 호스트가 한 번에 n 바이트를 받아서 처리할 수 있다면, 송신자는 이를 초과하지 않는 범위에서 데이터를 전송해야 한다.<br><br>
    ![](/assets/images/2024/2024-12-08-00-04-28.png)

<br>

## 3.2 TCP 흐름 제어의 핵심

> TCP는 송신자가 수신 호스트의 처리 속도에 맞춰 데이터를 전송하도록 흐름 제어를 수행한다.

- 이렇게 하면 송수신 속도를 균일하게 유지하고, 수신 호스트의 버퍼가 넘치는 상황(오버플로우)을 방지할 수 있다.
- Stop-and-Wait ARQ에서는 별도의 흐름 제어가 필요하지 않으나,
- Go-Back-N ARQ와 Selective Repeat ARQ 같은 파이프라이닝 기반의 프로토콜에서는 반드시 흐름 제어가 필요하다.

<br>

## 3.3 슬라이딩 윈도우: TCP 흐름 제어 기법

> 윈도우란, 송신 호스트가 파이프라이닝 할 수 있는 최대량을 의미한다.

- 윈도우 크기만큼 데이터를 확인 응답(ACK) 없이 전송할 수 있으며, 수신자가 ACK를 보내면 윈도우가 오른쪽으로 이동한다.
- 아래 예제에서는 첫 번째 세그먼트 ~ 네 번째 세그먼트까지가 확인 응답을 받지 않고도 전송할 수 있는 양이다.
- 윈도우 크기에서 벗어난 숫자에 해당하는 세그먼트는 전송할 수 없다.<br><br>
  ![](/assets/images/2024/2024-12-08-00-10-07.png)

<br>

> 수신 호스트로부터 첫 번째 세그먼트에 대한 ACK 세그먼트를 받았다면?

ACK 수신 → 윈도우가 오른쪽으로 "슬라이딩" 이동

![](/assets/images/2024/2024-12-08-00-11-30.png)

<br>

> 수신 호스트로부터 두 번째 세그먼트에 대한 ACK 세그먼트를 받았다면?

ACK 수신 → 윈도우가 점차 오른쪽으로 미끌어지듯(silding) 이동

![](/assets/images/2024/2024-12-08-00-12-33.png)

<br>

## 3.4 송신 윈도우와 수신 윈도우

- 수신 윈도우: 수신 호스트가 TCP 헤더(윈도우 필드)를 통해 송신자에게 알려주는 자신이 수신 가능한 데이터 크기
- 송신 윈도우: 송신자가 수신 윈도우의 크기를 바탕으로 전송 가능한 데이터를 계산한 값
- 송신 윈도우는 헤더로 전달받은 수신 윈도우 토대로 연산을 한다.<br><br>
  ![](/assets/images/2024/2024-12-08-00-13-49.png)

<br>

- 송신 호스트는 수신 윈도우를 넘지 않는 선에서 수신이 가능하게 끔 전송을 하게 된다.
- 💡 이처럼 윈도우 크기를 조절하며 송신량을 제한하는 이 과정이 TCP 흐름 제어의 핵심이다.<br><br>
  ![](/assets/images/2024/2024-12-08-00-15-48.png)

<br><br>

# 4. 혼잡 제어

## 4.1 혼잡 상태란?

> 혼잡(congestion)이란, 과도한 트래픽이 발생하여 패킷의 처리 속도가 늦어지거나 유실될 우려가 있는 네트워크 상황을 의미한다.

- 혼잡 상태가 발생하면:
  1. 패킷 유실 발생
  2. 유실된 패킷의 재전송 증가
  3. 추가적인 혼잡 발생 → 악순환

<br>

이를 방지하기 위해 송신 호스트는 네트워크 상태를 모니터링하여 전송량을 조절해야 한다.

![](/assets/images/2024/2024-12-08-00-16-56.png)

<br>

> TCP의 혼잡 제어의 주체

- 흐름 제어: 수신 호스트가 송신 호스트의 전송량을 제한
- 혼잡 제어: 송신 호스트가 네트워크 혼잡 상태를 고려하여 전송량을 조절

<br>

## 4.2 혼잡 윈도우

> 혼잡 윈도우(Congestion Window, CWND)는 네트워크 혼잡 상황에서 송신 가능한 데이터 양을 나타낸다.

- 혼잡 윈도우가 크면 -> 한 번에 전송할 수 있는 세그먼트 수가 많음
- 혼잡 윈도우가 작으면 -> (네트워크가 혼잡한 상황) 한 번에 전송할 수 있는 세그먼트 수가 적음

<br>

- 수신 윈도우는 수신 호스트가 헤더로 알려주지만, 혼잡 윈도우는 직접 계산해서 알아내야한다.
  - 따라서 TCP 헤더에는 굳이 혼잡 윈도우가 포함될 필요가 없다.
- 혼잡 윈도우 값을 연산하는 방법을 혼잡 제어 알고리즘이라고 한다.

<br>

## 4.3 TCP의 혼잡 제어 알고리즘

### 4.3.1 AIMD

> AIMD (Additive Increase / Multiplicative Decrease)은 가장 기본적인 알고리즘 ("합으로 증가, 곱으로 감소")

- 혼잡이 감지되지 않으면: 혼잡 윈도우 **RTT(Round Trip Time)** 마다 1씩 선형적으로 증가
- 혼잡이 감지되면: 혼잡 윈도우를 절반으로 떨어뜨리는 동작을 반복<br><br>
  ![](/assets/images/2024/2024-12-08-00-23-50.png)

AIMD는 네트워크 상태에 따라 혼잡 윈도우를 톱니 모양으로 변화시킨다.

<br>

> RTT (Round Trip Time)

메시지를 전송한 뒤 그에 대한 답변을 받는 데까지 걸리는 시간을 의미한다.

![](/assets/images/2024/2024-12-08-01-32-55.png)

<br>

### 4.3.2 느린 시작 알고리즘 (Slow Start)

> 혼잡 윈도우를 1부터 시작해, 문제 없이 수신된 ACK마다 윈도우 크기를 2배씩 지수적으로 증가시키는 방식

혼잡 윈도우는 RTT마다 2배씩 지수적으로 증가: 초기 전송 속도를 빠르게 확보하는 데 유리

![](/assets/images/2024/2024-12-08-01-34-31.png)

<br>

```
그럼 혼잡 윈도우 값을 무한정 늘릴 수 있을까?
```

- 그렇지 않다. **느린 시작 임계치**까지 혼잡 윈도우를 증가시킬 수 있다.
- 혼잡 윈도우 값이 계속 증가하다가,
  1. 혼잡 윈도우 크기가 느린 시작 임계치 이상이 되거나
  2. 타임아웃이 발생하거나
  3. 세 번의 중복된 ACK 세그먼트를 수신하면
  - 다음 세 가지 방법 중 하나를 선택한다.<br><br>
    ![](/assets/images/2024/2024-12-08-01-43-10.png)

<br>

### 4.3.3 혼잡 회피 알고리즘

> RTT마다 혼잡 윈도우를 1MSS 씩 증가 시키는 알고리즘

- 혼잡 윈도우 크기 선형적으로 증가
- 느린 시작 임계치 이후에는 혼잡 상태를 방지하기 위해 천천히 증가한다. ("워워워 진정해~")<br><br>
  ![](/assets/images/2024/2024-12-08-01-44-38.png)

<br>

### 4.3.4 빠른 회복(Fast Recovery) 알고리즘

```
세 번의 중복 세그먼트 수신 vs 타임아웃 중 뭐가 더 심각한 문제일까?
```

- 타임아웃이 더 심각한 문제이다!
- 중복된 ACK는 송신자가 특정 데이터 손실을 빠르게 감지할 수 있는 신호이지만, 타임아웃은 네트워크가 심각하게 혼잡하거나 수신 호스트와의 연결이 중단된 경우를 의미할 수 있다.

<br>

> 빠른 회복 알고리즘의 특징

- 세 번의 중복된 ACK가 발생하면:
  1. 빠른 재전송을 통해 손실된 세그먼트를 즉시 재전송.
  2. 이후 빠른 회복 알고리즘을 수행하여 혼잡 윈도우를 바로 회복하려 시도.
- 빠른 회복은 느린 시작 과정을 건너뛰고 바로 혼잡 회피 알고리즘을 수행

<br>

- 하지만 빠른 회복 도중이라도 타임아웃이 발생하면:
  1. 혼잡 윈도우 크기를 1로 초기화하고,
  2. 다시 느린 시작 알고리즘을 실행

<br>

## 4.4 혼잡 제어 알고리즘 요약

- 초기 단계: 느린 시작
  - 빠른 전송률 확보를 위해 혼잡 윈도우를 지수적으로 증가.
  - 혼잡 윈도우가 느린 시작 임계치를 초과하면, 혼잡 회피로 전환.
- 혼잡 회피
  - 느린 시작 임계치를 초과한 이후에는 혼잡을 방지하기 위해 혼잡 윈도우를 선형적으로 증가.
- 중복된 ACK 감지
  - 세 번의 중복된 ACK 수신 시, 빠른 재전송을 수행.
  - 재전송 이후 혼잡 회피를 거치지 않고, 빠른 회복 알고리즘 실행.
- 타임아웃 발생
  - 혼잡 윈도우를 1로 초기화.
  - 느린 시작부터 다시 시작.

<br>

> 혼잡 제어 흐름도

- 느린 시작 → 특정 임계치 도달 시 혼잡 회피
- 세 번의 중복 ACK → 빠른 재전송 → 빠른 회복
- 타임아웃 → 혼잡 윈도우 초기화 → 다시 느린 시작<br><br>
  ![](/assets/images/2024/2024-12-08-01-49-42.png)

<br>
