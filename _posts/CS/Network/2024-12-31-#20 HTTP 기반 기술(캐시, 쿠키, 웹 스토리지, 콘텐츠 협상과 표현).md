---
title: "[Network] #20 HTTP 기반 기술(캐시, 쿠키, 웹 스토리지, 콘텐츠 협상과 표현)"
categories: [Network]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[[혼자 공부하는 네트워크↗️]](https://www.youtube.com/watch?v=c62qssA4hYI&list=PLVsNizTWUw7HfOCgvlfHIDPPo3TE-2iQM), 컴퓨터 네트워킹: 하향식 접근 (제8판)을 바탕으로 정리한 글입니다.
{: .notice--danger}

- HTTP의 무상태(Stateless)와 비연결성 (Connectionless)특성으로 인해 서버는 클라이언트의 상태를 알 수 없다는 문제가 있다.
- 따라서 클라이언트의 상태를 알기 위해 쿠키, 세션, 토큰을 사용한다.
- 이번 포스팅에서는 HTTP 기반 기술에 대해서 학습해보자.

<br><br>

# 1. 캐시

## 1.1 캐시란?

> 캐시(cache)란, 응답 받은 자원의 **사본**을 임시 저장하는 기술을 의미한다.

- 추후 동일한 요청에 대해 캐시된 데이터를 활용할 수 있다.
- 불필요한 대역폭 낭비 방지, 응답 지연 방지
- 빠른 자원 접근 가능
- 개인 전용 캐시(private cache)
  - 웹 브라우저에 저장
- 공용 캐시(public cache)
  - 클라이언트와 서버 사이에 위치한 중간 서버에 저장<br><br>
    ![](/assets/images/2024/2024-12-31-15-24-02.png)

<br>

## 1.2 캐시 신선도의 검사와 유지

> 캐시는 자원의 **사본**을 저장한다. 즉, 캐시된 데이터는 언제든지 원본 데이터와 달라질 수 있다.

- 따라서 캐시 신선도를 고려해야한다.
- 캐시 신선도: 캐시된 사본 데이터가 얼마나 원본 데이터와 유사한지를 표현
- 그렇다면, 어떻게 캐시 신선도를 검사할 수 있을까?<br><br>
  ![](/assets/images/2024/2024-12-31-15-25-12.png)

<br>

### 1.2.1 캐시 신선도 검사: 유효 기간 설정

- 기간이 만료되었다면 원본 데이터를 다시 요청한다.
- 유효 기간 설정 방법
  - 응답 메시지의 Expires 헤더(날짜)와 Cache-Control 헤더의 Max-Age 값(초)을 사용
  - e.g., 캐시의 유효 시간을 2024년 2월 6일 화요일 12:00:00로 설정, 또는 1200초로 설정하는 응답 메시지<br><br>
    ![](/assets/images/2024/2024-12-31-15-27-49.png)

```
유효 기간이 끝났다고 가정했을 때, 새로운 데이터를 처음부터 다시 새롭게 갱신해야 할까?
그렇지 않다. 유효 기간이 끝났더라도, 서버의 원본 데이터가 변경되지 않았다면 그냥 캐시된 데이터를 사용하면 될 것이다.
```

<br>

### 1.2.2 캐시 신선도의 재검사

> ① If-Modified-Since 헤더

- 날짜를 기반으로 서버에게 물어보는 방법이다.
- If-Modified-Since 헤더에 명시된 시점 이후로 원본에 변경이 있었다면 그때만 새 자원으로 응답하도록 서버에게 요청하는 헤더이다.<br><br>
  ![](/assets/images/2024/2024-12-31-15-31-09.png)

<br>

- 아래는 "2024년 8월 23일 금요일 09:00:00 이후에 www.example.com/index.html의 자원이 변경 되었을 경우에만 새 자원으로 응답하라"는 요청 메시지이다.<br><br>
  ![](/assets/images/2024/2024-12-31-15-33-21.png)

<br>

- 서버의 Last-Modified 헤더
  - 상태 코드 304(not Modified)를 통한 자원의 "변경 여부" 뿐만 아니라, 자원이 마지막으로 수행된 시점도 알려줄 수 있다.
  - 304(not Modified)는 자원이 변경되지 않았을 경우 응답하는 상태 코드이다.
  - 즉, "캐시된 데이터가 변경되지 않았으니 그대로 쓰세요" 가 304(not Modified)인 것이다.
  - 아래는 2019년 10월 17일 목요일 7시 18분 26초에 변경 되었음을 알 수 있다.<br><br>
    ![](/assets/images/2024/2024-12-31-15-36-20.png)

<br>

> ② If-None-Match 헤더

- 엔티티 태그(Etag)를 기반으로 서버에게 물어보는 방법이다.
- Etag는 "자원의 버전"을 식별하기 위한 정보이다.
  - 버전이란 "유의미한 변경 사항"을 의미한다.
  - 즉, 자원이 변경될 때마다 자원의 버전을 식별하는 Etag 값이 변경된다.
  - 반대로 자원이 변경되지 않닸다면 Etag 값도 변경되지 않는다.<br><br>
    ![](/assets/images/2024/2024-12-31-15-42-39.png)

<br>

- 따라서 클라이언트는 Etag 값과 일치하는 자원이 있니? 라고 서버에게 물어봄으로써 변경사항이 있는지 확인할 수 있다.
- 아래는 "Etag 값이 abc인 www.example.com/index.html이라는 자원이 있니? 자원이 변경되었다면(Etag 값이 바뀌었다면) 그때만 새 자원으로 응답해줘" 라는 메시지이다.<br><br>
  ![](/assets/images/2024/2024-12-31-15-44-27.png)

<br><br>

# 2. 쿠키

## 2.1 쿠키란?

> 서버에서 생성되어 클라이언트 측에 저장되는 데이터

- 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단이다.
- 기본적으로 <이름, 값> 쌍의 형태, 추가로 다양한 속성을 가질 수 있다.
- 요청이 같은 클라이언트에서 왔는지, 로그인 상태를 유지하고 있는지 등을 알 수 있다.<br><br>
  ![](/assets/images/2024/2024-12-31-15-57-34.png)

<br>

## 2.2 세션 인증

> 쿠키를 활용하는 인증 기술이 세션 인증이다.

- HTTP는 스테이트리스 프로토콜이다.
- 따라서, 같은 클라이언트가 서버에 여러 번 요청을 보낸다고 해도, 기본적으로 서버는 모든 요청들을 별개의 요청으로 간주한다.

```
클라이언트가 서버에 요청 메시지를 보낼 때마다 (아이디, 비밀번호와 같은) 인증 정보를 보내고 번거로운 인증 과정을 거쳐야 하는 것일까?
-> 쿠키를 사용해서 인증을 구현한다면 그럴 필요가 없다.
```

<br>

> 세션 아이디(session id)와 세션 인증(session authentication)

1. 클라이언트는 서버에게 (아이디, 비밀번호와) 같은 인증 정보를 전송
2. 인증 정보가 올바르다면, 서버는 세션 아이디를 생성해 클라이언트에게 전송
3. 서버는 생성한 세션 아이디를 DB 등에 저장
4. 클라이언트는 추후 요청을 보낼 때 쿠키 내에 세션 아이디를 포함하여 전송
5. 서버는 쿠키 속 세션 아이디와 저장된 세션 아이디를 비교하여 클라이언트 식별<br><br>
   ➡️ 요청을 보낼 때마다 번거로운 인증 과정을 거칠 필요가 없다.

<br>

## 2.3 서버의 쿠키 생성과 클라이언트의 활용

> 서버에서 클라이언트로 쿠키를 전송하기 위해 HTTP 헤더를 사용한다.

- 서버는 클라이언트에게 "Set-Cookie" 헤더를 통해서 쿠키를 전달 하고,
- 클라이언트는 서버에게 "Cookie" 헤더를 통해 쿠키를 전달한다.

<br>

> 응답 메시지의 Set-Cookie 헤더

- 쿠키의 이름, 값과 더불어 세미콜론(;)으로 구분되는 속성(들)을 전달
- 한 응답 메시지에 전달할 쿠키가 여러 개라면 다음과 같이 여러 개의 Set-Cookie<br><br>
  ![](/assets/images/2024/2024-12-31-16-21-49.png)

<br>

> 요청 메시지의 Cookie 헤더

- 서버에 전달할 쿠키의 이름과 값을 나태내는 헤더
- 여러 개의 쿠키 값을 서버에게 전달해야 할 떄는 세미 콜론(;)을 사용<br><br>
  ![](/assets/images/2024/2024-12-31-16-24-11.png)

<br>

> 서버의 쿠키 생성 - 클라이언트의 쿠키 활용 예제

- name="minchul", phone="100-100", message="Hello"라는 쿠키를 클라이언트에게 전송<br><br>
  ![](/assets/images/2024/2024-12-31-16-24-43.png)

<br>

- 앞의 서버로부터 전달 받은 쿠키를 활용<br><br>
  ![](/assets/images/2024/2024-12-31-16-26-16.png)

<br>

> 브라우저에서 쿠키를 직접 확인해보자

- 쿠키는 브라우저에서 저장되고 관리
- 크롬 브라우저에서 개발자 도구를 열고, [Application] - [Storage] - [Cookies]
- 아래와 같이 쿠키에는 다양한 속성들이 있는 것을 확인할 수 있다.<br><br>
  ![](/assets/images/2024/2024-12-31-16-28-13.png)

<br>

## 2.4 쿠키의 여러 속성

### 2.4.1 Domain

> 쿠키는 사용 가능한 도메인이 정해져 있다.

- www.naver.com에게 받은 쿠키를 전혀 다른 웹사이트인 www.google.com에게 전송하면 안된다.
- 이렇게 쿠키가 사용할 수 있는 도메인 네임을 제한하기 위한 속성이 Domain이다.
- 응답 메시지 속 Set-Cookie 헤더의 "domain" 속성으로 정한다.<br><br>
  ![](/assets/images/2024/2024-12-31-16-29-30.png)

<br>

### 2.4.2 Path

> 같은 도메인이라도 쿠키를 구분하여 사용하고 싶을 경우 사용한다.

- path 속성으로 쿠키가 적용될 경로를 명시: 지정된 경로 + 하위 경로에서 쿠키 활용
- e.g., www.example/lectures를 포함한 하위 경로에서 사용하고자 하는 쿠키와 www.example.com/books를 포함한 하위 경로에서 사용하고자 하는 쿠키를 구분하고 싶을 경우<br><br>![](/assets/images/2024/2024-12-31-16-48-16.png)

<br>

### 2.4.3 Expires / Max-Age

> 쿠키 유효 기간과 관련한 속성

- Expires 속성을 통해 쿠키 만료 시점 지정
- Max-Age 속성을 통해 초 단위 유효 기간 지정<br><br>
  ![](/assets/images/2024/2024-12-31-16-49-37.png)

<br>

### 2.4.4 Secure와 HttpOnly

> 쿠키의 한계

- 쿠키의 대표적인 한계는 보안이다.
- 쿠키 정보는 쉽게 노출되거나 조작될 수 있다.

<br>

> Secure와 HttpOnly

- Secure
  - HTTPS 프로토콜이 사용되는 경우에만 쿠키 전송
  - HTTPS 프로토콜은 HTTP를 더 안전한 방식으로 전송할 수 있는 프로토콜
- HttpOnly: HTTP 송수신을 통해서만 쿠키를 이용하도록 제한하는 속성
  - 쿠키 관련 데이터는 JS를 통해서도 접근 가능
  - HttpOnly는 JS에서 쿠키에 접근하지 못하도록 하는 속성

<br><br>

# 3. 쿠키와 유사한 웹 스토리지

> 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 새롭게 지원하는 저장소이다.

- 웹 스토리지는 웹 브라우저 내에 저장된다.
- 쿠키는 약 4KB까지 밖에 저장 공간을 이용하지 못하는 반면에 웹 스토리지는 약 5MB까지 저장 공간을 이용할 수 있다.
- 웹스토리지는 쿠키와 달리 서버로 데이터를 전송하지 않고, 클라이언트 측에서 데이터를 저장하므로 서버에 부담이 가지 않는다.
- 웹 스토리지는 로컬 스토리지, 세션 스토리지로 분류할 수 있으며 가장 큰 차이점은 데이터의 영구성에 있다.
- 로컬 스토리지와 세션 스토리지는 window 객체의 프로퍼티로서 존재하며, 같은 Storage 객체를 상속하기 때문에 동일한 메소드들을 가진다.

<br>

## 3.1 로컬 스토리지

> 로컬 스토리지에 저장된 데이터는 사용자가 직접 삭제하지 않는 한 영구적으로 저장된다.

- 영구 저장: 로컬 스토리지에 저장된 데이터는 브라우저를 닫아도 사용자의 컴퓨터에 영구적으로 저장된다.
- 도메인 별로 저장: 로컬 스토리지는 도메인(웹사이트) 단위로 데이터를 저장한다. 서로 다른 브라우저 탭이라도 동일한 도메인이라면 동일한 로컬 스토리지를 사용한다.
- 자동 로그인과 같은 지속적으로 필요한 정보를 저장하기 좋다.

<br>

## 3.2 세션 스토리지

> 세션 스토리지는 로컬 스토리지와 유사한 웹 스토리지 기술이지만, 주로 세션 동안만 데이터를 저장하는 데 사용된다.

- 세션은 사용자가 웹사이트에 접속한 후 브라우저를 닫을 때까지의 기간을 의미한다.

- 세션 동안만 저장: 세션 스토리지에 저장된 데이터는 세션 동안만 유지되어 브라우저를 닫을 때 저장된 데이터가 삭제된다.
- 도메인 별로 저장: 로컬 스토리지와 마찬가지로, 세션 스토리지도 도메인 단위로 데이터를 저장한다.
- 일회성 로그인 등 잠시 동안 필요한 정보를 저장하기에 좋다.

<br>

> 개발자 도구를 활용해 로컬 스토리지와 세션 스토리지를 확인할 수 있다.

![](/assets/images/2024/2024-12-31-17-22-30.png)

<br>

## 3.3 웹 스토리지 API

> 웹 스토리지는 기본적으로 키(key)와 값(value)으로 이루어진 데이터를 저장할 수 있다.

웹 스토리지 API 주요 메서드

|       메서드        |                                        설명                                        |
| :-----------------: | :--------------------------------------------------------------------------------: |
| setItem(key, value) |                       지정된 키와 값을 스토리지에 저장한다.                        |
|    getItem(key)     | 지정된 키에 해당하는 값을 스토리지에서 가져온다, 키가 존재하지 않을 경우 null 반환 |
|   removeItem(key)   |                  지정된 키에 해당하는 값을 스토리지에서 제거한다.                  |
|       clear()       |           스토리지에 저장된 모든 키-값 쌍을 제거하여 스토리지를 비운다.            |
|       length        |                   스토리지에 저장된 키-값 쌍의 개수를 반환한다.                    |
|     key(index)      |                       정된 인덱스에 해당하는 키를 반환한다.                        |

<br>

> 아래처럼 웹 스토리지 API를 사용하면 클라이언트 측에서 간단한 데이터 저장과 관리를 쉽게 할 수 있다.

```jsx
// 로컬 스토리지에 데이터 저장
localStorage.setItem("name", "sieun");
localStorage.setItem("age", "22");

// 세션 스토리지에서 데이터 읽기
const name = sessionStorage.getItem("name");
console.log(name); // "sieun"

// 로컬 스토리지에서 데이터 제거
localStorage.removeItem("age");

// 스토리지 비우기
sessionStorage.clear();
```

<br><br>

# 4. 콘텐츠 협상과 표현

## 4.1 콘텐츠 협상이란?

> HTTP의 특성을 다시 확인해보자.

- 클라이언트는 서버에 자원을 요청하고, 서버는 요청받은 자원을 응답한다.
- 자원은 URI(URL)로 특정 가능하다.

<br>

> HTTP는 위와 같은 특성을 가지고 있음에도, 왜 같은 URL에 대해 같은 요청을 보냈는데 다른 응답을 받을까?

- 한국에서 접속하거나 한국어 계정으로 특정 URL에 접속하면 한국어로 된 웹 페이지
- 다른 지역에서 접속하거나 영어 계정으로 같은 URL에 접속하면 영어로 된 웹 페이지<br><br>

  ![](/assets/images/2024/2024-12-31-17-28-38.png)

<br>

> 바로 콘텐츠 협상 때문이다.

- 콘텐츠 협상이란, 같은 URI에 대해 가장 적합한 **"자원의 형태"** 를 제공하는 메커니즘이다.
- 같은 URI로 식별 가능한 HTML 문서라 해도 영어로 요청하면 영어로 된 형태를 제공, 한국어로 요청하면 한국어로 된 형태를 제공한다.
- 여기서 자원의 형태를 표현이라고 부른다.

<br>

## 4.2 자원의 표현

> 송수신 가능한 자원의 형태를 의미한다.

즉, 콘텐츠 협상은 클라이언트에게 가장 적합한 자원의 표현을 제공하는 메커니즘이다.

<br>

## 4.2 콘텐츠 협상 관련 HTTP 헤더

|               헤더                |               설명               |
| :-------------------------------: | :------------------------------: |
|            Accept 헤더            |       선호하는 미디어 타입       |
|          Accept-Language          |          선호하는 언어           |
| Accept-Charset 및 Accept-Encoding | 선호하는 문자 인코딩과 압축 방식 |

<br>

e.g., 클라이언트가 선호하는 언어가 한국어 및 클라이언트가 HTML 문서 타입을 선호

![](/assets/images/2024/2024-12-31-17-26-07.png)

<br>

> 선호도에 우선순위 반영

- 클라이언트가 여러 개의 미디어 타입, 언어, 압축 방식을 선호할 경우 클라이언트는 선호하는 표현의 우선순위를 부여할 수 있다.
- 우선 순위는 콘텐츠 협상 관련 헤더의 q값으로 표현한다. (q는 Quality Value의 약자)
  - 값이 클수록 우선순위가 높음
  - 생략되었을 경우에는 1을 의미
  - 범위는 0부터 1까지

<br>

- 아래는 클라이언트가 한국어(ko-KR, ko), 영어(en-US, en)순으로 선호하고, HTML, XML, 일반 텍스트 순으로 선호한다는 의미이다.<br><br>
  ![](/assets/images/2024/2024-12-31-17-45-29.png)

<br>
