---
title: "[Algorithm/Java] 백준 1003번 - 피보나치 함수"
categories: [Algorithm]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[https://www.acmicpc.net/problem/1003](https://www.acmicpc.net/problem/1003)

---

<br>

# 📌 문제

## 문제 유형

- DP

<br>

## 문제 설명

> 재귀로 구현된 피보나치 함수 fibonacci(n)이 0과 1을 각각 몇 번 출력하는지 구하는 문제

1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.

<br>

## 입출력 예시

> 입력

```java
3
0
1
3
```

> 출력

각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.

```java
1 0
0 1
1 2
```

<br><br>

# 🔍 문제 풀이

> **다이나믹 프로그래밍(DP)이란?**

- 큰 문제를 작은 문제로 나눠서 푸는 알고리즘 설계 기법
- 이미 푼 문제의 정답을 저장해두고, 중복 계산을 피하는 방식이다.
- 재귀로 풀면 같은 계산을 반복하게 되어 비효율적인데, 이 문제를 DP로 풀면 방식으로 0과 1이 각각 몇 번 출력되는지 미리 계산해두어 속도를 비약적으로 줄일 수 있다/.

<br>

> **① 0과 1의 출력 횟수를 각각 DP 배열에 저장하기로 결정**

관계식

```java
count0[3] = count0[2] + count0[1] = 1 + 0 = 1
count1[3] = count1[2] + count1[1] = 1 + 1 = 2
```

- fibonacci(3)을 호출하면:
  - 0이 출력된 횟수 → 1번
  - 1이 출력된 횟수 → 2번

<br>

> **② DP 배열 초기값 세팅 (`dp[0]`, `dp[1]`)**

```java
count0[0] = 1; // fibonacci(0) → 0 출력
count1[0] = 0;

count0[1] = 0; // fibonacci(1) → 1 출력
count1[1] = 1;
```

| n   | dp[n][0] (0 출력 횟수) | dp[n][1] (1 출력 횟수) |
| --- | ---------------------- | ---------------------- |
| 0   | 1                      | 0                      |
| 1   | 0                      | 1                      |
| 2   | 0                      | 0                      |
| 3   | 0                      | 0                      |
| 4   | 0                      | 0                      |
| ... | ...                    | ...                    |
| 40  | 0                      | 0                      |

<br>

> **③ DP채우기(점화식)**

- 최대 n은 40이므로, 미리 0~40까지 DP 배열을 채운다.
- `fib(n)`은 `fib(n-1) + fib(n-2)`이므로, 출력 횟수도 이전 두 값을 더하면 된다.

```java
for (int i = 2; i <= 40; i++) {
    dp[i][0] = dp[i - 1][0] + dp[i - 2][0];
    dp[i][1] = dp[i - 1][1] + dp[i - 2][1];
}
```

| n   | fibonacci(n) 호출 시        | dp[n][0] (0 출력 횟수) | dp[n][1] (1 출력 횟수) |
| --- | --------------------------- | ---------------------- | ---------------------- |
| 0   | fibonacci(0)                | 1                      | 0                      |
| 1   | fibonacci(1)                | 0                      | 1                      |
| 2   | fibonacci(1) + fibonacci(0) | 1 (0+1)                | 1 (1+0)                |
| 3   | fibonacci(2) + fibonacci(1) | 1 (1+0)                | 2 (1+1)                |
| 4   | fibonacci(3) + fibonacci(2) | 2 (1+1)                | 3 (2+1)                |
| ... | ...                         | ...                    | ...                    |

<br>

> ④ 이후 각 테스트케이스에서 `dp[n][0]`, `dp[n][1]` 을 출력

<br><br>

# 💭 놓친 점

> 놓친 점 1)

<br>

> 놓친 점 2)

<br><br>

# 💻 전체 코드

```java

// DP는 중복되는 연산을 저장해서 재활용하는 게 핵심이에요.
// 그래서 배열을 선언하고, 작은 문제부터 차례대로 누적 계산해가는 방식이 많음
package org.example;

import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int t = Integer.parseInt(br.readLine());

        // dp[i][0] = fib(i) 호출 시 0이 출력되는 횟수
        // dp[i][1] = fib(i) 호출 시 1이 출력되는 횟수
        int[][] dp = new int[41][2];

        // base case
        // fib(0)은 0을 출력하고 끝남 (0 출력 1번, 1 출력 0번)
        dp[0][0] = 1;
        dp[0][1] = 0;
        // fib(1)은 1을 출력하고 끝남 (0 출력 0번, 1 출력 1번)
        dp[1][0] = 0;
        dp[1][1] = 1;

        // dp 채우기(점화식)
        for (int i = 2; i <= 40; i++) {
            dp[i][0] = dp[i - 1][0] + dp[i - 2][0];
            dp[i][1] = dp[i - 1][1] + dp[i - 2][1];
        }

        // 테스트 케이스 처리
        for (int i = 0; i < t; i++) {
            int n = Integer.parseInt(br.readLine());
            System.out.println(dp[n][0] + " " + dp[n][1]);
        }

    }
}
```

<br>
