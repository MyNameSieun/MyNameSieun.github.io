---
title: "[Algorithm/Java] 백준 17413번 - 단어 뒤집기2"
categories: [Algorithm]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[https://www.acmicpc.net/problem/17413](https://www.acmicpc.net/problem/17413)

---

<br>

# 🔍 문제 풀이

## 문제 도식화

![17413 도식화](<../../../assets/images/2025/17413 도식화.png>)

<br>

## 배운 점

처음에는 `<`와 `>` 사이에 있는 문자를 단순히 출력하면 되겠지 싶었는데,<br>
막상 코드를 짜보니 태그 안과 밖의 처리를 구분하지 않으면<br>
출력 순서가 이상하게 되는 문제가 생겼다。

그 과정에서 `isFlag` boolean 변수를 사용해서<br>
지금 태그 안인지 밖인지를 기억하는 방식이 효과적이라는 걸 알게 됐다.

이 플래그를 기준으로<br>
태그 안에서는 문자를 그대로 출력하고<br>
태그 밖에서는 스택에 넣었다가 뒤집어서 출력하는 방식으로 구현할 수 있었다.

<br><br>

# 💻 전체 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        Stack<Character> stack = new Stack<>();
        String str = br.readLine();
        boolean isFlag = false; // 태그 안인지 여부

        for(int i=0; i<str.length(); i++){
            char ch = str.charAt(i);

            // 단어가 끝나고 태그가 시작되므로, 스택에 쌓인 문자 먼저 뒤집어서 출력
            if(ch == '<'){
                while(!stack.isEmpty()){
                    System.out.print(stack.pop());
                }
                isFlag = true; // 태그 시작 상태로 설정
                System.out.print(ch); // '<' 출력
            }
            else if(ch == '>'){
                isFlag = false; // 태그 종료
                System.out.print(ch); // '출력'
            }
            // 태그 내부는 그대로 출력
            else if(isFlag){
                System.out.print(ch);
            }
            // 공백을 만나면 지금까지 쌓인 단어를 역순으로 출력
            else if(ch == ' '){
                while(!stack.isEmpty()){
                    System.out.print(stack.pop());
                }
                System.out.print(' '); // 공백도 출력(주의)
            }
            // 일반 평문이면 스택에 넣기
            else{
                stack.push(ch);
            }
        }

        // 마지막에 남은 문자 처리
        while(!stack.isEmpty()){
            System.out.print(stack.pop());
        }
    }
}
```

<br>
