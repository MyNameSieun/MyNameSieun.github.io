---
title: "[Algorithm/Java] 백준 2606번 - 바이러스"
categories: [Algorithm]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[https://www.acmicpc.net/problem/2606](https://www.acmicpc.net/problem/2606)

---

<br>

# 📌 문제

## 문제 유형

- 그래프 탐색

<br>

## 문제 설명

- 신종 바이러스가 컴퓨터를 통해 전파된다.
- 1번 컴퓨터가 바이러스에 걸렸을 때, 네트워크 상에서 **1번 컴퓨터를 통해 바이러스에 걸리게 되는 컴퓨터의 수**를 구하라.

<br>

## 입출력 예시

> 입력

첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.

```
7
6
1 2
2 3
1 5
5 2
5 6
4 7
```

> 출력

1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.

```
4
```

<br><br>

# 🔍 문제 풀이

1. 인접 행렬에 간선 정보 입력
2. BFS로 1번 노드부터 연결된 노드 탐색
3. 방문한 노드 수(count) 출력 (1번 제외)

(DFS도 사용 가능하지만 BFS가 더 빠르기 때문에 사용)

<br>

## 인접 행렬

> 개념

- **2차원 배열**을 이용하여 노드 간 연결 여부를 표현
- `graph[i][j] == 1`이면 i번과 j번 노드가 연결되어 있다는 뜻
- `graph[i][j] == 0`이면 연결되지 않음

> 초기화 방법 (Java)

```java
int[][] graph = new int[n + 1][n + 1];
```

> 간선 정보 저장

```java
graph[a][b] = 1;
graph[b][a] = 1;  // 무방향 그래프
```

<br>

> 예시

입력:

```
1 2
2 3
```

인접 행렬:

```
      1 2 3
    -------
1 |  0 1 0
2 |  1 0 1
3 |  0 1 0
```

<br><br>

# 💻 전체 코드

```java
package org.example;

import java.io.*;
import java.util.*;

public class Main {
    static int[][] graph;
    static boolean[] visited;
    static int n, m, v;
    static int count = 0;

    public static void bfs(int start){
        Queue<Integer> q = new LinkedList<>();
        q.offer(start);
        visited[start] = true;

        while (!q.isEmpty()) {
            int current = q.poll();

            for (int i = 1; i <= n; i++) {
                if (graph[current][i] == 1 && !visited[i]) {
                    visited[i] = true;
                    q.offer(i);
                    count++;  // 시작 노드를 제외하고 감염된 컴퓨터 수
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine()); // 노드 수
        m = Integer.parseInt(br.readLine()); // 간선 수

        graph = new int[n + 1][n + 1];
        visited = new boolean[n + 1];

        for (int i = 0; i < m; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            graph[a][b] = 1;
            graph[b][a] = 1;
        }

        bfs(1);  // 1번 컴퓨터에서 시작
        System.out.println(count);
    }
}
```

<br><br>

# 💭 배운 점

파이썬보다 자바는 자료형 선언, 배열 초기화, 입력 처리 등 세부 사항을 직접 지정해야 해서 처음엔 조금 번거로웠다.

하지만 자바에서는 count를 전역 변수로 선언해 BFS 내부에서 바로 값을 누적할 수 있어, 메인 함수에서 따로 반환값을 처리하지 않아도 된다는 점은 오히려 편하게 느껴졌다.

<br>
