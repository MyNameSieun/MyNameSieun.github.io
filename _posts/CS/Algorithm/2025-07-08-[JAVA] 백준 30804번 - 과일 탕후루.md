---
title: "[Algorithm/Java] 백준 30804번 - 과일 탕후루"
categories: [Algorithm]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[https://www.acmicpc.net/problem/30804](https://www.acmicpc.net/problem/30804)

---

<br>

# 📌 문제

> 문제 유형

- 구현
- 브루투포스
- 투 포인터

<br>

> 문제 설명

N개의 과일이 순서대로 꽂힌 막대에서 앞과 뒤에서 몇 개를 제거해,<br>
과일 종류가 최대 2종류인 연속 부분을 만들려고 한다.

과일의 개수가 가장 많은 경우의 수를 구하시오.

<br>

> 입력

첫 줄에 과일의 개수
$N$이 주어집니다.
$(1 \le N \le 200\,000)$

둘째 줄에 탕후루에 꽂힌 과일을 의미하는
$N$개의 정수
$S_1, \cdots, S_N$이 공백으로 구분되어 주어집니다.
$(1 \le S_i \le 9)$

```
5
5 1 1 2 1
```

과일을 앞에서
$1$개, 뒤에서
$0$개의 과일을 빼면 남은 과일은
$1, 1, 2, 1$번 과일이 꽂혀있는 탕후루가 됩니다. 과일의 개수는
$4$개입니다

> 출력

문제의 방법대로 만들 수 있는 과일을 두 종류 이하로 사용한 탕후루 중에서, 과일의 개수가 가장 많은 탕후루의 과일 개수를 첫째 줄에 출력하세요.

```
4
```

<br><br>

# 🔍 문제 풀이

1. `fruits[]` 배열에 과일 정보를 저장한다. (각 과일은 1~9 중 하나)
2. `count[]` 배열을 통해 과일 번호별 등장 횟수를 저장한다. (index = 과일 번호)
3. 투 포인터를 사용해 구간을 유지한다.
   - `left`는 현재 구간의 시작 인덱스
   - `right`는 현재 구간의 끝 인덱스를 슬라이딩하며 탐색
4. `kind` 변수로 현재 구간에 등장하는 과일 종류 수를 관리한다.
5. `kind > 2`일 경우:
   - 왼쪽 과일부터 하나씩 제거하면서 `kind`가 2 이하가 될 때까지 구간 축소
6. 매 이동마다 `right - left + 1`을 통해 최대 길이 `maxLen` 갱신

<br><br>

# 📌 놓친 점

## if가 아닌 while 사용

> 과일 종류가 2개를 초과하는 동안 계속 줄여야 하기 때문에 if가 아닌 while 사용이 필요하다.

처음에는 if문으로 조건을 확인하고 제거하면 될 것이라 생각했지만,<br>
과일 종류가 2개 이하가 될 때까지 여러 번 제거해야 할 수도 있기 때문에 while 반복문이 필요했다.

kind > 2가 되면 left 포인터를 오른쪽으로 이동시키며 윈도우를 축소하고,<br>
`count[fruits[left]]`를 감소시켜 과일 개수를 줄이고,<br>
만약 특정 과일의 개수가 0이 되면 kind도 감소시켜 과일 종류 수도 줄인다.

이 과정을 종류가 2개 이하가 될 때까지 반복해야 하므로 while을 써야 한다.

<br>

## count 배열 관리

과일을 제거할 때 단순히 `count--`만 하지 않고,

그 과일의 개수가 0이 되었는지도 확인해서 `kind--`를 해줘야 한다.

<br>

## 최대 길이 갱신

길이를 계속 덮어쓰면 안 되고

`maxLen = Math.max(maxLen, right - left + 1)`으로 최댓값만 갱신해야 한다.

<br><br>

# 💻 전체 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int n = Integer.parseInt(br.readLine());

        int[] fruits = new int[n];

        // 입력
        StringTokenizer st = new StringTokenizer(br.readLine());
        for(int i=0; i<n; i++){
            fruits[i] = Integer.parseInt(st.nextToken());
        }

        int[] count = new int[10]; // 과일 종류별 ㄱ수
        int kind = 0;
        int left = 0;
        int maxLan = 0;

        for(int right = 0; right<n; right++) {
            if(count[fruits[right]] == 0) kind++;
            count[fruits[right]]++; // 새로운 종류 등장

            // 과일 종류가 2개 초과하면 왼쪽 포인터 이동
            while(kind > 2){
                count[fruits[left]]--;
                if(count[fruits[left]] == 0) kind--;
                left++;
            }

            // 최대 길이 찾기
            maxLan = Math.max(maxLan, right-left + 1);
        }
        System.out.println(maxLan);

    }
}
```

<br>
