---
title: "[Algorithm/Java] 백준 6064번 - 카잉 달력"
categories: [Algorithm]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[https://www.acmicpc.net/problem/6064](https://www.acmicpc.net/problem/6064)

---

<br>

# 📌 문제

> 문제 유형

- 수학
- 브루트포스
- 정수론
- 중국인의 나머지 정리

<br>

> 문제 설명

![](/assets/images/2025/2025-07-08-18-24-01.png)

<br>

> 입력

![](/assets/images/2025/2025-07-08-18-23-47.png)

```
3
10 12 3 9
10 12 7 2
13 11 5 6
```

> 출력

![](/assets/images/2025/2025-07-08-18-24-16.png)

```
33
-1
83
```

<br><br>

# 🔍 문제 풀이

**① 최소공배수 범위 안에서 해를 탐색**

> M과 N의 최소공배수까지는 모든 경우가 순환되므로, k는 최대 lcm(M, N)까지만 보면 된다.

예시: M=5, N=7

```
1: <1,1> 6: <1,6> 11<1,4> 16<1,2> 21<1,7> 26<1,5> 31<1,3>
2: <2,2> 7: <2,7> 12<2,5> 17<2,3> 22<2,1> 27<2,6> 32<2,4>
3: <3,3> 8: <3,1> 13<3,6> 18<3,4> 23<3,2> 28<3,7> 33<3,5>
4: <4,4> 9: <4,2> 14<4,7> 19<4,5> 24<4,3> 29<4,1> 34<4,6>
5: <5,5> 10:<5,3> 15<5,1> 20<5,6> 25<5,4> 30<5,2> 35<5,7>
```

- 36년부터는 1년 차랑 똑같아짐
- 즉, 36년부터는 1~35년 내용을 다시 복사해서 반복하는 것과 같음 (x는 5년마다 한 바퀴, y는 7년마다 한 바퀴)
- 둘 다 동시에 처음 상태로 돌아오려면 5와 7의 공통 반복 지점이 필요함 -> 최소공배수 = 35년
- 정리하자면,
  - M년, N년 주기로 반복되는 달력이므로
  - 두 주기가 동시에 다시 시작되는 해 = 최소공배수(LCM(M, N))
  - 그 이후는 똑같이 반복되므로 LCM까지만 보면 충분

<br>

**② x부터 시작해서 `k += M`씩 증가시키며 `(k % N == y)`인지 확인**

```java
for (int k = x; k < lcm; k += m)
```

찾는 해 k는 아래 조건을 만족해야한다.

```
k ≡ x (mod M)  →  k % M == x
k ≡ y (mod N)  →  k % N == y
```

그런데 x부터 시작해서 `k += M`씩 가면 `k % M == x`는 항상 만족한다.

<br>

> 예시: M = 5, N = 7, x = 2, y = 1

k ≡ 2 mod 5 -> k = 2, 7, 12, 17, 22, 27, 32

이 중에서 `k % 7 == 1`이 되는지 확인

```
2 % 7 = 2   -> x
7 % 7 = 0   -> x
12 % 7 = 5  -> x
17 % 7 = 3  -> x
22 % 7 = 1  -> o
```

정답: k = 22

<br>

따라서, x부터 시작해서 m씩 증가시키면 항상 `k % m == x`를 만족하는 해만 보게 된다.

<br>

**③ 이제 k % N == y만 맞는지 확인하면 된다.**

- x 조건은 이미 만족된 상태니까 y만 확인하기
- `k = x`부터 `k += M`씩 가면서 `k % N == y`만 보면 됨
- 만족하면 그 `k`가 정답
- 없으면 끝까지 돌고 `-1` 출력

<br><br>

# 💻 전체 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringBuilder sb = new StringBuilder();
        int t = Integer.parseInt(br.readLine());

        while (t-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int m = Integer.parseInt(st.nextToken());
            int n = Integer.parseInt(st.nextToken());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());

            int gcd = getGCD(m, n);
            int lcm = m * n / gcd; // 최소 공배수

            boolean found = false;

            for (int k = x; k <= lcm; k += m) {
                int modY = (k - 1) % n + 1;
                if (modY == y) {
                    sb.append(k).append("\n");
                    found = true;
                    break;
                }
            }

            if (!found) {
                sb.append("-1\n");
            }
        }

        System.out.print(sb);
    }

    private static int getGCD(int m, int n) {
        if(n == 0) return m;
        return getGCD(n, m % n);
    }
}
```

<br><br>

# 참조

- [https://1-7171771.tistory.com/38](https://1-7171771.tistory.com/38)

<br>
