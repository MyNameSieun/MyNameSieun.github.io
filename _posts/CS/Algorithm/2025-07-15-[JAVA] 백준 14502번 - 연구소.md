---
title: "[Algorithm/Java] 백준 14502번 - 연구소"
categories: [Algorithm]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[https://www.acmicpc.net/problem/14502](https://www.acmicpc.net/problem/14502)

---

<br>

# 🔍 문제 풀이

## 문제 도식화

![14502 도식화](<../../../assets/images/2024/14502 도식화.png>)

<br>

## 알고리즘 선택

- 벽을 3개 세우는 건 조합을 모두 탐색해야 하기 때문에 **DFS 기반의 백트래킹**으로 구현했고,
- 벽이 세워진 뒤 바이러스 전파는 동시에 여러 방향으로 퍼지는 특성을 고려해 **BFS**로 처리했다.

<br><br>

# 💻 전체 코드

```java
import java.io.*;
import java.util.*;

public class Main {
    static int[][] board;
    static int[][] copyBoard;

    static int n, m;
    static int maxSafe = 0;

    public static void main (String[]args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 입력
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken()); // 열
        m = Integer.parseInt(st.nextToken()); // 행

        board = new int[n][m];
        copyBoard = new int[n][m];

        // 초기화
        for(int i=0; i<n; i++){
            st = new StringTokenizer(br.readLine());
            for(int j=0; j<m; j++){
                board[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        buildWall(0);
        System.out.println(maxSafe);
    }

    // 벽 세우기 (조건: map[i][j]=0이여야함, 무조건 3개)
    static void buildWall(int cnt){
        if(cnt == 3){
            spreadVirus(); // 벽 3개 세운 경우에만 시뮬레이션 실행
            return;
        }
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(board[i][j] == 0){
                    board[i][j] = 1;
                    buildWall(cnt + 1);
                    board[i][j] = 0; // 백트래킹
                }
            }
        }
    }

    // 바이러스 퍼트리기
    static void spreadVirus(){
        for(int i=0; i<n; i++){
            copyBoard[i] = board[i].clone(); // 배열 한 줄씩 복사 (깊은복사)
        }

        Deque<int[]> dq = new ArrayDeque<>();

        // 바이러스 위치 큐에 추가
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(copyBoard[i][j] == 2){
                    dq.offer(new int[]{i, j});
                }
            }
        }

        int[] dx = {-1, 1, 0, 0};
        int[] dy = {0, 0, -1, 1};

        while (!dq.isEmpty()){
            int[] cur = dq.poll();
            int cx = cur[0];
            int cy = cur[1];

            for(int i=0; i<4; i++){
                int nx = cx + dx[i];
                int ny = cy + dy[i];

                if(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                if(copyBoard[nx][ny] == 0){
                    copyBoard[nx][ny] = 2;
                    dq.offer(new int[]{nx, ny});
                }
            }
        }

        int safe = 0;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(copyBoard[i][j] == 0) safe++;
            }
        }

        maxSafe = Math.max(maxSafe, safe);

    }
}
```

<br>
