---
title: "[Algorithm/Java] SWEA 5105 - 미로의 거리"
categories: [Algorithm]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[SWEA 5105 - 미로의 거리](https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVuPDN86AAXw5UW6&subjectId=AWOVIoJqqfYDFAWg#)

---

<br>

# 🔍 문제 풀이

## 문제 도식화

![assets/images/2025/SWEA 5105.jpg](<../../../assets/images/2025/SWEA 5105.jpg>)

<br><br>

# 💻 코드

## 전체 코드

```java
import java.io.*;
import java.util.*;

public class Solution {
    static int[][] graph;
    static int[][] visited;
    static int n;

    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());

        for (int tc = 1; tc <= T; tc++) {
            n = Integer.parseInt(br.readLine());

            graph = new int[n][n];

            int sx = -1, sy = -1;
            for(int i=0; i<n; i++){
                String line = br.readLine();
                for(int j=0; j<n; j++){
                    graph[i][j] = line.charAt(j) - '0';
                    if(graph[i][j] == 2){
                        sx = i; sy = j;
                    }
                }
            }

            int ans = bfs(sx, sy);

            System.out.println(ans);

        }
    }

    static int bfs(int sx, int sy) {
        // 1.큐, 방문 배열 초기화
        Deque<int[]> dq = new ArrayDeque<>();
        visited = new int[n][n];

        // 2. 시작 노드 등록
        dq.offer(new int[]{sx, sy});
        visited[sx][sy] = 1;

        // 3. 현재 노드(좌표) 탐색
        while(!dq.isEmpty()){
            int[] cur = dq.poll();
            int cx = cur[0];
            int cy = cur[1];

            // 4방향 순회
            for(int d=0; d<4; d++){
                int nx = cx+dx[d];
                int ny = cy+dy[d];

                // 범위 확인
                if(nx < 0 || nx >= n || ny < 0 || ny >= n) continue;

                // 종료조건
                if(graph[nx][ny] == 3){
                    return visited[cx][cy] - 1;
                }

                // 다음 위치가 0이거나 미방문이면
                if(graph[nx][ny] == 0 && visited[nx][ny] == 0){
                    visited[nx][ny] = visited[cx][cy] + 1;
                    dq.offer(new int[]{nx, ny});
                }
            }
        }


        return 0;
    }
}
```

<br>

## 스켈레톤 코드

```java
import java.io.*;
import java.util.*;

public class Solution {
    static int[][] graph;
    static int[][] visited;
    static int n;

    static int[] dx = {-1, 1, 0, 0};
    static int[] dy = {0, 0, -1, 1};

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());

        for (int tc = 1; tc <= T; tc++) {
            n = Integer.parseInt(br.readLine());

            graph = new int[n][n];

            int sx = -1, sy = -1;
            for(int i=0; i<n; i++){
                String line = br.readLine();
                for(int j=0; j<n; j++){
                    graph[i][j] = line.charAt(j) - '0';
                    if(graph[i][j] == 2){
                        sx = i; sy = j;
                    }
                }
            }

            int ans = bfs(sx, sy);

            System.out.println(ans);

        }
    }

    static int bfs(int sx, int sy) {

        return 0;
    }
}
```

<br>
