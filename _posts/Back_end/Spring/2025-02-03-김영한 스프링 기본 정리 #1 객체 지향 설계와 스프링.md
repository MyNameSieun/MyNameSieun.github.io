---
title: "[Spring] 김영한 스프링 기본 정리 #1 객체 지향 설계와 스프링"
categories: [Spring]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

# 1. 스프링이란?

## 1.1 스프링 프레임워크

- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비

<br>

## 1.2 스프링 부트

> 스프링을 편리하게 사용할 수 있도록 지원하며, 최근에는 기본으로 사용 된다.

- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
- 스프링과 3rd party(외부) 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

<br>

## 1.3 스프링의 핵심 개념

> 스프링은, 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크다.

- 스프링은 자바 언어(객체 지향 언어) 기반의 프레임워크
- 즉, 스프링은 좋은 객체 지향 앱을 개발할 수 있게 도와주는 프레임워크

<br><br>

# 2. 좋은 객체 지향 프로그래밍

## 2.1 객체 지향 특징

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 "**객체**"들의 **모임**으로 파악하고자 하는 것이다.
- 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
- 유연하고, 변경이 용이? -> 다형성(Polymorphism)

<br>

## 2.2 다형성 (Polymorphism)

> <span style="color:indianred">역할(인터페이스)과 구현(클래스)으로 구분</span>

역할과 구현을 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.

- 역할(인터페이스): **무엇을 해야 하는지(행동, 기능)** 를 정의한다.
  - e.g., MemberRepository라는 인터페이스는 **"회원 정보를 저장하고 조회해야 한다"** 는 역할을 정의
- 구현(클래스): 어떻게 그 역할을 수행할지를 구체적으로 정의한다.
  - e.g., 메모리에 저장하는 구현, DB에 저장하는 구현

아래 예제를 살펴보자.

<br>

![](/assets/images/2025/2025-02-05-19-43-12.png)

운전자는 K3를 타다 아반떼로 차를 바꿔도 차를 탈 수 있음

왜냐하면 자동차의 역할에 대한 구현만 변경됐기 때문

운전자(클라이언트)는 자동 차의 내부 구조를 몰라도 됨

<br>

> 위 예시처럼 <span style="color:indianred">역할과 구현을 분리</span>하는 데 장점은 아래와 같다.

- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 **내부 구조를 몰라도** 된다.
- 클라이언트는 구현 대상의 **내부 구조가 변경**되어도 영향을 받지 않는다.
- 클라이언트는 구현 **대상 자체를 변경**해도 영향을 받지 않는다.

<br>

> 자바 언어는 다형성을 활용한다.

- 객체를 설계할 때 역할과 구현을 명확히 분리한다.
- 따라서 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체를 만드는 식으로 개발을 진행한다.
- 역할 자체가 변하면 클라이언트, 서버 모두 큰 변경이 발생하므로, 인터페이스를 안정적으로 설계하는 것이 가장 중요하다. (e.g., 자동차를 비행기로 변경해야 한다면?)
  - 역할 = 인터페이스
  - 구현 = 인터페이스를 구현한 클래스, 구현 객체

<br>

> 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 즉, 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있는 것이 다형성의 본질이다.

<br>

## 2.3 스프링과 객체 지향

> 스프링의 꽃은 다형성이다.

- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 마치 레고 블럭 조립하듯이, 공연 무대의 배우를 선택하듯이 구현을 편리하게 변경할 수 있다.

<br><br>

# 3. 좋은 객체 지향 설계의 5가지 원칙(SOLID)

> 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리

- SRP: 단일 책임 원칙(single responsibility principle)
- OCP: 개방-폐쇄 원칙⭐ (Open/closed principle)
- LSP: 리스코프 치환 원칙 (Liskov substitution principle)
- ISP: 인터페이스 분리 원칙 (Interface segregation principle)
- DIP: 의존관계 역전 원칙⭐ (Dependency inversion principle)

<br>

## 3.1 SRP 단일 책임 원칙

> 한 클래스는 하나의 책임만 가져야 한다.

- 하나의 책임이라는 것은 모호하다.
  - 클 수 있고, 작을 수 있으며, 문맥과 상황에 따라 다르다.
- 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
- e.g., UI 변경, 객체의 생성과 사용을 분리

<br>

## 3.2 OCP 개방-폐쇄 원칙

> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다

- 다형성을 활용하면 당연히 기존 코드를 변경하지 않고 확장이 가능하다.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현할 수 있기 때문이다.

<br>

> 하지만, OCP 개방-폐쇄 원칙은 아래와 같은 문제가 존재한다.

![](/assets/images/2025/2025-02-05-22-52-14.png)

- MemberService 클라이언트가 구현 클래스를 직접 선택한다.
- 구현 객체를 변경하려면 **클라이언트 코드를 변경**해야 한다.
- 분명 다형성을 사용했지만 **OCP 원칙을 지킬 수 없다.**

<br>

```
이 문제를 어떻게 해결하면 어떻게 해야할까?
```

객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

<br>

## 3.3 LSP 리스코프 치환 원칙

> 부모 클래스(또는 인터페이스)로 정의된 객체는 자식 클래스로 대체되더라도 프로그램의 동작이 바뀌지 않아야 한다는 원칙

- 자식 클래스는 부모 클래스의 행위를 일관성 있게 유지해야 하며, 부모로 정의된 모든 기능을 정상적으로 수행할 수 있어야 한다.
- e.g., 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함

<br>

## 3.4 ISP 인터페이스 분리 원칙

> 하나의 큰 인터페이스를 여러 개의 작은 인터페이스로 나누어, 각 인터페이스가 특정 클라이언트의 요구에 맞도록 설계해야 한다는 원칙

- 인터페이스를 최소한의 기능으로 분리하여 각각의 클라이언트에 맞게 제공해야 한다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.
- e.g.,
  - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
  - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
  - 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않는다.

<br>

## 3.5 DIP 의존관계 역전 원칙

> **상위 모듈**은 **하위 모듈**에 의존하면 안 되고, 둘 다 구체화(구현 클래스)가 아닌 추상화(인터페이스)에 의존해야 한다는 원칙이다.

- DIP에서는 구체적인 구현 클래스가 아니라 역할을 담당하는 인터페이스에만 의존해야 한다는 게 핵심이다.
- 앞서 설명 한 역할(Role)에 의존하게 해야 한다는 것과 같다.

<br>

> DIP 위반

아래 코드를 보자.

```java
public class MemberService {
   private MemberRepository memberRepository = new MemoryMemberRepository();
 }
```

- **MemberService**는 **상위 모듈**이다. 프로그램의 주요 비즈니스 로직을 처리하는 서비스 계층이다.
- **MemberRepository**는 **인터페이스** 이다. 데이터 저장소 역할을 일반화해서 여러 구현체를 사용할 수 있도록 설계된 추상화이다.
- **MemoryMemberRepository**는 **구현 클래스(저수준 모듈)** 이다. 메모리에 데이터를 저장하는 실제 구현체이다.

<br>

MemberService는 MemberRepository라는 인터페이스에 의존해야 하는 것이 맞지만,

현재는 MemoryMemberRepository라는 구체적인 구현 클래스에 직접적으로 의존하고 있다.

<br>

```
만약 MemoryMemberRepository 대신 JDBC로
데이터를 저장하는 구현체(e.g., JdbcMemberRepository)로 변경하려면 어떻게 될까?
```

이렇게 하려면 MemberService 코드를 수정해야 한다.

DIP의 원칙에 따르면 상위 모듈은 하위 모듈의 세부사항에 영향을 받지 말아야 한다. 즉, 이런 코드 수정은 DIP 원칙을 위반한 것이다.

<br>

```
Q. 이를 해결하려면?

A. 생성자 주입으로 의존성을 역전하면 된다.
```

MemberService는 구체적인 클래스가 아니라 MemberRepository 인터페이스에 의존하게 하고, 구체적인 구현체는 외부에서 주입받도록 개선할 수 있다.

해결 방법은 뒤에서 자세히 알아보자.

<br>

## 3.6 정리

> 객체 지향의 핵심은 다형성이다.

- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다. 구현 객체를 변경할 때 클라이언트 코드도 함께 변경되기 때문이다.
- 또한 다형성 만으로는 OCP, DIP를 지킬 수 없다.
- 뭔가 더 필요하다.

<br><br>

# 4. 객체 지향 설계와 스프링

> 스프링 이야기에 왜 객체 지향 이야기가 나올까?

- 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원한다.
  - DI(Dependency Injection): 의존관계, 의존성 주입
  - DI 컨테이너 제공
- 따라서 클라이언트 코드의 변경 없이 기능 확장할 수 있다.
- 쉽게 부품을 교체하듯이 개발할 수 있게 된 것이다.

<br>

> 스프링이 없던 시절...

- 옛날 개발자들이 순수 자바로 DIP와 OCP 원칙을 지키려다 보니 너무 번거로워졌다.
- 이를 자동화하고 반복 작업을 줄이기 위해 스프링 DI 컨테이너가 탄생한 것이다.
- 결과적으로 스프링은 객체 간의 의존성을 자동으로 관리해줌으로써 좋은 객체 지향 설계를 실현할 수 있게 해준다.

<br>

다음 포스팅에서 스프링이 왜 만들어졌는지 코드로 이해해보도록 하자.

<br>
