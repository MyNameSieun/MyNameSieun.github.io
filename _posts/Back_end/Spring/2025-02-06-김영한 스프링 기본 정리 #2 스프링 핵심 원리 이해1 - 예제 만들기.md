---
title: "[Spring] 김영한 스프링 기본 정리 #2 스프링 핵심 원리 이해1 - 예제 만들기"
categories: [Spring]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

이번 포스팅에서 스프링이 왜 만들어졌는지 <span style="color:indianred">역할과 구현 분리</span>에 집중하여 예제를 만들며 이해해보도록 하자.

---

<br>

# 1. 프로젝트 생성

> 사전 준비물

- Java 17 이상 설치
- IDE: IntelliJ 설치

> [스프링 부트 스타터 사이트](https://start.spring.io)로 이동해서 스프링 프로젝트 생성

![](/assets/images/2025/2025-02-06-00-43-24.png)

⚠️ 스프링 부트 3.0 이상, JDK 17 이상을 사용해야 한다.

<br>

압축을 풀고, `bulid.gradle` 을 open 해주면 된다.

<br>

주의! 스프링 부트 3.2 부터 Build and run using에 Gradle 옵션을 선택해야 한다. (default)

![](/assets/images/2025/2025-02-06-01-01-42.png)

<br><br>

# 2. 비즈니스 요구사항과 설계

<span style="color:indianred">미확정</span> 정책을 개발하기 위해 인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계하면 된다.

> 회원

- 회원을 가입하고 조회할 수 있다.
- 회원은 일반과 VIP 두 가지 등급이 있다.
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. <span style="color:indianred">(미확정)</span>

> 주문과 할인 정책

- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다.
- 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
- 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루
  고 싶다. 최악의 경우 할인을 적용하지 않을 수도 있다. <span style="color:indianred">(미확정)</span>

<br><br>

# 3. 회원 도메인 설계

> 회원 도메인 요구사항

- 회원을 가입하고 조회할 수 있다.
- 회원은 일반과 VIP 두 가지 등급이 있다.
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. <span style="color:indianred">(미확정)</span>

<br>

> 회원 도메인 협력 관계 (기획자 확인 가능)

- 회원 데이터는 미확정된 정책이기 때문에, 회원 저장소라는 인터페이스를 만들어 회원 데이터의 접근하는 계층을 따로 설정한다.
- 클라이언트 역할, 회원 서비스 역할, 회원 저장소 역할이 있으며 회원 저장소의 역할을 3개의 저장소로 나눈다.

![](/assets/images/2025/2025-02-06-01-19-02.png)

<br>

> 회원 클래스 다이어그램 (정적, 위 그림을 바탕으로 개발자가 구체화)

![](/assets/images/2025/2025-02-06-01-18-54.png)

<br>

> 회원 객체 다이어그램 (동적, 클라이언트가 실제로 사용하는 인스턴스 끼리의 참조)

객체 간의 메모리간의 참조를 그린 그림이다.

![](/assets/images/2025/2025-02-06-02-43-17.png)

<br><br>

# 4. 회원 도메인 개발

앞으로 개발할 member 패키지 파일 구조는 다음과 같다.

![](/assets/images/2025/2025-02-06-02-40-35.png)

<br>

## 4.1 회원 엔티티

> member라는 패키지를 생성해준 후, Enum(열거형)으로 Grade와 Class로 Member을 생성하자.

회원 등급

```java
package hello.core.member;

public enum Grade {
    BASIC,
    VIP
}
```

회원 엔티티

```java
package hello.core.member;

public class Member {
    private Long id;
    private String name;
    private Grade grade;


    // 생성자
    public Member(Long id, String name, Grade grade) {
        this.id = id;
        this.name = name;
        this.grade = grade;
    }

    // Getter, Setter
    public Long getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Grade getGrade() {
        return grade;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setGrade(Grade grade) {
        this.grade = grade;
    }
}
```

- 생성자 단축키
  - Mac: Command + N
  - Window: Alt + Insert
- Getter, Setter 단축키
  - Alt + Insert

<br>

## 4.2 회원 저장소

> member 패키지 안에 `MemberRepository` 인터페이스를 생성하고, 회원을 저장하는 기능과 회원을 찾는 기능을 만들자.

회원 저장소 인터페이스

```java
package hello.core.member;

public interface MemberRepository {
    void save(Member member);

    Member findById(Long memberId);
}

```

<br>

> 그리고 member 패키지 안에 `MemoryMemberRepository`라는 클래스 생성 후, implements로 MemberRepository를 설정하자.

메모리 회원 저장소 구현체체

```java
package hello.core.member;

import java.util.HashMap;
import java.util.Map;

public class MemoryMemberRepository implements MemberRepository{

    // (실무에서는 HashMap 대신 ConcurrentHashMap를 사용한다.)
    private static Map<Long, Member> store = new HashMap<>();
    @Override
    public void save(Member member) {
        store.put(member.getId(), member);

    }

    @Override
    public Member findById(Long memberId) {
        return store.get(memberId);
    }
}
```

<br>

## 4.2 회원 서비스 만들기

> member 패키지 안에 `MemberService`라는 인터페이스를 만들자.

MemberService는 회원 가입, 회원 조회 기능을 가져야 한다.

![](/assets/images/2025/2025-02-06-01-19-02.png)

<br>

회원 서비스 인터페이스

```java
package hello.core.member;

public interface MemberService {
    void join(Member member);

    Member findMember(Long memberId);
}
```

<br>

> 인터페이스를 만들었으니, member 패키지 안에 `MemberServiceImpl`이라는 클래스를 생성하여 구현체를 만들자.

회원 서비스 구현체

(관례상 구현체가 하나만 있을 때, 인터페이스 뒤에 Impl을 사용한다고 한다.)

```java
package hello.core.member;

public class MemberServiceImpl implements MemberService{

    // MemoryMemberRepository라는 구현 객체 선택
    private final MemberRepository memberRepository = new MemoryMemberRepository();

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```

<br><br>

# 5. 회원 도메인 실행과 테스트

> main의 hello.core에다 `MemberApp`이라는 클래스를 생성 후, 아래와 같이 테스트 해보자.

## 5.1 회원 도메인 - 회원 가입 main

```java
package hello.core;

import hello.core.member.*;

public class MemberApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        Member member = new Member(1L, "memberA", Grade.VIP);
        memberService.join(member);

        Member findMember = memberService.findMember(1L);
        System.out.println("new member = " + member.getName());
        System.out.println("find Member = " + findMember.getName());
    }
}
```

애플리케이션 로직으로 이렇게 테스트 하는 것은 좋은 방법이 아니다. JUnit 테스트를 사용하자.

<br>

## 5.2 회원 도메인 - 회원 가입 테스트

> test의 hello.core에다 `member`이라는 패키지를 만든 후, `MemberServiceTest` 클래스를 생성 하여 아래와 같이 테스트를 진행하자.

검증은 org.assertj.core.api의 Assertions을 사용하여 진행한다.

![](/assets/images/2025/2025-02-06-03-10-14.png)

```java
package hello.core.member;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;

public class MemberServiceTest {

    MemberService memberService = new MemberServiceImpl();

    @Test
    void join(){
        // given
        Member member = new Member(1L, "memberA", Grade.VIP);

        // when
        memberService.join(member);
        Member findMember = memberService.findMember(1L);

        // then
        Assertions.assertThat(member).isEqualTo(findMember);

    }

}
```

성공!

![](/assets/images/2025/2025-02-06-03-12-21.png)

<br>

## 5.3 회원 도메인 설계의 문제점

> 위 코드의 설계상 문제점은 무엇일까?

- 다른 저장소로 변경할 때 OCP 원칙을 잘 준수하고 있을까?
- DIP를 잘 지키고 있을까요?

➡️ 의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있다.

아래 주문까지 만들고나서 해결해보자.

<br><br>

# 6. 주문과 할인 도메인 설계

> 주문과 할인 도메인인 요구사항

- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다.
- 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
- 할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루
  고 싶다. 최악의 경우 할인을 적용하지 않을 수도 있다. <span style="color:indianred">(미확정)</span>

<br>

> 주문 도메인 협력, 역할, 책임

![](/assets/images/2025/2025-02-06-03-16-38.png)

1. 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
2. 회원 조회: 할인을 위해서는 회원 등급이 필요하다. 그래서 주문 서비스는 먼저 회원 저장소에서 회원을 조회한다.
3. 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다.
4. 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.

<br>

> 주문 도메인 전체

- 아래처럼 <span style="color:indianred">역할과 구현을 분리</span>해서 자유롭게 구현 객체를 조립할 수 있게 설계하였다. (역할 먼저 만들고, 구현을 그 다음에)
- 덕분에 회원 저장소는 물론이고, 할인 정책도 유연하게 변경할 수 있다.<br><br>
  ![](/assets/images/2025/2025-02-06-03-17-33.png)

<br>

> 주문 도메인 클래스 다이어그램

![](/assets/images/2025/2025-02-06-03-18-58.png)

<br>

> 주문 도메인 객체 다이어그램1

앞에서 설명했듯, 객체 다이어그램은 클래스 다이어그램과 다르게 new를 통해 생성하여 동적으로 연관관계가 맺어지는 것을 뜻한다.

![](/assets/images/2025/2025-02-06-03-19-12.png)

회원을 메모리에서 조회하고, 정액 할인 정책(고정 금액)을 지원해도 주문 서비스를 변경하지 않아도 된다.

역할들의 협력 관계를 그대로 재사용 할 수 있다. (정액할인 -> 정률할인으로 변경 되어도 주문 서비스 구현체를 변경하지 않아도 된다는 것을 뜻함.)

<br>

> 주문 도메인 객체 다이어그램2

![](/assets/images/2025/2025-02-06-03-19-33.png)

회원을 메모리가 아닌 실제 DB에서 조회하고, 정률 할인 정책(주문 금액에 따라 % 할인)을 지원해도 주문 서비스를 변경하지 않아도 된다.

협력 관계를 그대로 재사용 할 수 있다.

<br><br>

# 7. 주문과 할인 도메인 개발

> 먼저, `hello.core`에다 `discount`이라는 패키지를 만들고, 패키지 아래다가 `DiscountPolicy`라는 인터페이스를 만들어주자.

## 7.1 할인 정책 인터페이스

```java
package hello.core.discount;

import hello.core.member.Member;

public interface DiscountPolicy {
    // return 할인 대상 금액
    int discount(Member member, int price);
}
```

<br>

## 7.2 정액 할인 정책 구현체

> discount 패키지 하위에 `FixDiscountPolicy`라는 구현체(클래스)를 생성하여 `DiscountPolicy`를 implements 한 뒤, 정액 할인 구현체 코드를 작성하자.

```java
package hello.core.discount;

import hello.core.member.Grade;
import hello.core.member.Member;

public class FixDiscountPolicy implements DiscountPolicy{

    private int discountFixAmount = 1000; // 1000원 할인

    @Override
    public int discount(Member member, int price) {
        // VIP면 1000원 할인, 아니면 할인 없음
        if(member.getGrade()== Grade.VIP){
            return discountFixAmount;
        } else {
            return 0;
        }

    }
}

```

<br>

## 7.3 주문 엔티티

> `hello.core` 하위에 `order`이라는 패키지 만들고 클래스 `Order`을 생성해주자.

```java
package hello.core.order;

public class Order {
    private Long memberId;
    private String itemName;
    private int itemPrice;
    private int discountPrice;

    public Order(Long memberId, String itemName, int itemPrice, int discountPrice) {
        this.memberId = memberId;
        this.itemName = itemName;
        this.itemPrice = itemPrice;
        this.discountPrice = discountPrice;
    }

    public int calculatePrice(){
        return itemPrice-discountPrice;
    }

    // Getter, Setter
    public Long getMemberId() {
        return memberId;
    }

    public String getItemName() {
        return itemName;
    }

    public int getItemPrice() {
        return itemPrice;
    }

    public int getDiscountPrice() {
        return discountPrice;
    }

    public void setMemberId(Long memberId) {
        this.memberId = memberId;
    }

    public void setItemName(String itemName) {
        this.itemName = itemName;
    }

    public void setItemPrice(int itemPrice) {
        this.itemPrice = itemPrice;
    }

    public void setDiscountPrice(int discountPrice) {
        this.discountPrice = discountPrice;
    }

    @Override
    public String toString() {
        return "Order{" +
                "memberId=" + memberId +
                ", itemName='" + itemName + '\'' +
                ", itemPrice=" + itemPrice +
                ", discountPrice=" + discountPrice +
                '}';
    }
}
```

toString() 을 사용하면 객체를 출력할 때, 편리하게 데이터를 확인할 수 있다.

![](/assets/images/2025/2025-02-06-04-13-41.png)

<br>

## 7.4 주문 서비스 인터페이스

order 패키지 안에 `OrderService`라는 인터페이스를 만들어 회원 id, 상품명, 상품 가격을 넘기면 주문 결과가 반환되는 코드를 작성해주면 된다.

![](/assets/images/2025/2025-02-06-04-18-46.png)

```java
package hello.core.order;

public interface OrderService {
    Order createOrder(Long memberId, String itemName, int itemPrice);
}
```

<br>

## 7.5 주문 서비스 구현체

order 패키지에 `OrderServiceImpl`이라는 구현체(클래스)를 만들자.

```java
package hello.core.order;

import hello.core.discount.DiscountPolicy;
import hello.core.discount.FixDiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberRepository;
import hello.core.member.MemoryMemberRepository;

public class OrderServiceImpl implements OrderService{

    private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final DiscountPolicy discountPolicy = new FixDiscountPolicy();

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

주문 생성 요청이 오면, 먼저 회원 정보를 조회하고, 할인 정책을 적용한 다음 주문 객체를 생성해서 반환한다.

메모리 회원 리포지토리와, 고정 금액 할인 정책을 구현체로 생성한다.

<br><br>

# 8. 주문과 할인 도메인 실행과 테스트

## 8.1 주문과 할인 정책 실행

> main의 hello.core에다 `OrderApp`이라는 클래스를 생성 후, 아래와 같이 테스트 해보자.

```java
package hello.core.order;

import hello.core.member.Grade;
import hello.core.member.Member;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;

public class OrderApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        OrderService orderService = new OrderServiceImpl();

        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);
        memberService.join(member);

        Order order = orderService.createOrder(memberId, "itemA", 10000);

        System.out.println("order = " + order);
    }
}
```

<br>

![](/assets/images/2025/2025-02-06-05-05-06.png)

할인 금액이 잘 출력되는 것을 확인할 수 있다.

애플리케이션 로직으로 이렇게 테스트 하는 것은 좋은 방법이 아니다. JUnit 테스트를 사용하자.

<br>

## 8.2 주문과 할인 정책 테스트

> test의 hello.core에다 `order`라는 패키지를 만든 후, `OrderServiceTest` 클래스를 생성 하여 아래와 같이 테스트를 진행하자.

검증은 org.assertj.core.api의 Assertions을 사용하여 진행한다.

![](/assets/images/2025/2025-02-06-03-10-14.png)

```java
package hello.core.order;

import hello.core.member.Grade;
import hello.core.member.Member;
import hello.core.member.MemberService;
import hello.core.member.MemberServiceImpl;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;

public class OrderServiceTest {
    MemberService memberService = new MemberServiceImpl();
    OrderService orderService = new OrderServiceImpl();

    @Test
    void createOrder(){
        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);
        memberService.join(member);

        Order order = orderService.createOrder(memberId, "itemA", 10000);
        Assertions.assertThat(order.getDiscountPrice()).isEqualTo(1000);
    }
}
```

<br>
