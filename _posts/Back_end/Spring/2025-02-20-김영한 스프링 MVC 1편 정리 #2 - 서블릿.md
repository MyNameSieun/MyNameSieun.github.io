---
title: "[Spring] 김영한 스프링 MVC 1편 정리 #2 - 서블릿"
categories: [Spring]
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

서블릿은 Java를 사용할 때 웹 페이지를 동적으로 생성하는 서버측 프로그램이다.

웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해준다. (WAS 내부에서 실행)

이를 통해 HTTP 요청 데이터와 응답 데이터를 효과적으로 처리하는 방법을 고민할 수 있으며, 주로 어떤 방식이 사용되는지 알아보자.

<br>

# 1. 프로젝트 세팅

## 1.1 프로젝트 생성

> 사전 준비물

- Java 17 이상 설치
- IDE: IntelliJ 설치

> [스프링 부트 스타터 사이트](https://start.spring.io)로 이동해서 스프링 프로젝트 생성

- 프로젝트 선택
  - Project: **Gradle - Groovy** Project
  - Language: Java
  - Spring Boot: 3.x.x
- Project Metadata
  - Group: hello
  - Artifact: servlet
  - Name: servlet
  - Package name: hello.servlet
  - Packaging: **War (주의!)**
  - Java: 17 또는 21
- Dependencies: **Spring Web**, **Lombok**

![](/assets/images/2025/2025-02-21-07-32-13.png)

<br>

⚠️ Packaging는 Jar가 아니라 War를 선택해야한다. JSP를 실행하기 위해서 필요하다.

<br>

⚠️ 스프링 부트 3.2 부터 Build and run using에 Gradle 옵션을 선택해야 한다. (default)

![](/assets/images/2025/2025-02-06-01-01-42.png)

<br>

프로젝트 생성 후, 압축을 풀고 `build.gradle`을 실행하자.

<br>

## 1.2 동작 확인

> 동작 확인

- 기본 메인 클래스 실행(`ServletApplication.main()`)
- [http://localhost:8080](http://localhost:8080) 호출해서 Whitelabel Error Page가 나오면 정상 동작

<br>

## 1.3 롬복 적용

> 롬복 적용 (window: File -> Setting)

① Preferences plugin lombok 검색 실행 (재시작)

![](/assets/images/2025/2025-02-21-07-45-07.png)

<br>

② Preferences Annotation Processors 검색 Enable annotation processing 체크 (재시작)

![](/assets/images/2025/2025-02-21-07-46-55.png)

<br>

③ 임의의 테스트 클래스를 만들고 @Getter, @Setter 확인

<br>

## 1.4 Postman 설치

[www.postman.com](https://www.postman.com/downloads/)에서 Postman을 다운로드 받고 설치

<br><br>

# 2. Hello 서블릿

> 스프링 부트 환경에서 서블릿 등록하고 사용해보자.

스프링 부트는 톰캣 서버를 내장하고 있으므로, 톰캣 서버 설치 없이 편리하게 서블릿 코드를 실행할 수 있다.

<br>

## 2.1 스프링 부트 서블릿 환경 구성

> 스프링 부트는 서블릿을 직접 등록해서 사용할 수 있도록 `@ServletComponentScan` 을 지원한다.

아래와 같이 추가하자.

```java
package hello.servlet;

@ServletComponentScan // 서블릿 자동 등록
@SpringBootApplication
public class ServletApplication {

	public static void main(String[] args) {
		SpringApplication.run(ServletApplication.class, args);
	}
}
```

<br>

## 2.2 서블릿 등록하기

> 생성한 프로젝트 `hello.servlet` 하위에 `basic`라는 패키지를 만들어 `HelloServlet` 클래스를 만들어 실제 동작하는 서블릿 코드를 등록해보자. (`hello.servlet.basic.HelloServlet`)

서블릿은 클라이언트의 요청을 받아 처리하고, 동적 웹 페이지나 다른 응답을 생성하는 자바 프로그램이다.

이 서블릿은 `/hello` URL로 들어오는 HTTP 요청을 받아 `service()` 메서드를 통해 요청을 처리하고 응답을 생성하는 역할을 한다.

<br>

💡 Override 메서드 생성 단축키: `Ctrl + O`를 눌러 자물쇠 있는 service 메서드를 선택<br>
(단축키 확인: 설정 > Keymap > Override Methods )

![](/assets/images/2025/2025-02-21-08-10-31.png)

<br>

`req`는 클라이언트의 요청 정보를 담고 있는 객체이고, `resp`는 그 요청에 대한 서버의 응답을 작성해서 보내는 객체이기 때문에 응답 메시지는 resp로 보내는 것이다.

```java
package hello.servlet.basic;

@WebServlet(name="helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("HelloServlet.service");
        System.out.println("req = " + req);
        System.out.println("resp = " + resp);

    }
}

```

- `@WebServlet` 서블릿 애노테이션
  - name: 서블릿 이름 (서블릿 이름은 아무거나 부여해도 됨)
  - urlPatterns: URL 매핑
- HTTP 요청을 통해 매핑된 URL이 호출되면 서블릿 컨테이너는 다음 메서드를 실행한다.
  - `protected void service(HttpServletRequest request, HttpServletResponse response)`

![](/assets/images/2025/2025-02-21-08-20-51.png)

<br>

빈 화면이면 성공!

![](/assets/images/2025/2025-02-21-08-13-36.png)

<br>

> `http://localhost:8080/hello?username=park`와 같이 쿼리 파라미터를 읽을 수 있도록 해보자!

서블릿은 쿼리 파라미터를 편하게 읽도록 지원해준다.

```java
package hello.servlet.basic;

import java.io.IOException;

@WebServlet(name="helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("HelloServlet.service");
        System.out.println("req = " + req);
        System.out.println("resp = " + resp);

        // 쿼리 파라미터
        String username = req.getParameter("username");
        System.out.println("username = " + username);
    }
}
```

<br>

> 이번에는 `HttpServletResponse`를 통해 응답 메시지를 보내보자.

```java
package hello.servlet.basic;


import java.io.IOException;

@WebServlet(name="helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("HelloServlet.service");
        System.out.println("req = " + req);
        System.out.println("resp = " + resp);

        // 쿼리 파라미터
        String username = req.getParameter("username");
        System.out.println("username = " + username);

        // 응답 메시지 보내기
        resp.setContentType("text/plain");
        resp.setCharacterEncoding("utf-8");
        resp.getWriter().write("hello " + username);
    }
}
```

![](/assets/images/2025/2025-02-21-08-33-01.png)

<br>

## 2.3 HTTP 요청 메시지 로그로 확인하기

> `main/resources/application.properties`에 다음 설정을 추가하자.

```
logging.level.org.apache.coyote.http11=trace
```

<br>

> 서버를 다시 시작하고, 요청해보면 서버가 받은 HTTP 요청 메시지를 출력하는 것을 확인할 수 있다.

⚠️ 운영서버에 이렇게 모든 요청 정보를 다 남기면 성능저하가 발생할 수 있다. 개발 단계에서만 적용하자.

![](/assets/images/2025/2025-02-21-08-38-50.png)

<br>

## 2.4 서블릿 컨테이너 동작 방식 설명

① 스프링 부트 실행 → 내장 톰캣 서버가 함께 실행됨

② 톰캣 서버 내부의 서블릿 컨테이너가 서블릿을 생성 및 관리

![](/assets/images/2025/2025-02-21-08-40-01.png)

<br>

③ 클라이언트(웹 브라우저)가 `hello?username=world` 요청을 보내면, 요청된 HTTP 메시지가 서버로 전달

![](/assets/images/2025/2025-02-21-08-45-26.png)

<br>

④ 서블릿 컨테이너가 `request`, `response` 객체를 생성하고, `helloServlet`(싱글톤) 호출 및 요청 전달

⑤ 서블릿이 요청을 처리하고 응답을 생성한 후, 서블릿 컨테이너가 응답을 클라이언트(웹 브라우저)에게 반환

![](/assets/images/2025/2025-02-21-08-45-44.png)

<br>

💡 HTTP 응답에서 Content-Length는 웹 애플리케이션 서버가 자동으로 생성해준다.

<br>

## 2.5 welcome 페이지 추가

- `main`에 Directory로 `webapp`을 생성한 뒤, File로 `index.html`, `basic.html` 생성
- `! + Tab`: 에밋 기능 사용하여 기본 html 문서 구조 자동 생성

<br>

그냥 아래 코드 복붙하자 (프론트를 공부하는 것은 아니기 때문)

> `main/webapp/index.html`

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <ul>
      <li><a href="basic.html">서블릿 basic</a></li>
    </ul>
  </body>
</html>
```

<br>

> `main/webapp/basic.html`

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
  </head>
  <body>
    <ul>
      <li>
        hello 서블릿
        <ul>
          <li><a href="/hello?username=servlet">hello 서블릿 호출</a></li>
        </ul>
      </li>
      <li>
        HttpServletRequest
        <ul>
          <li><a href="/request-header">기본 사용법, Header 조회</a></li>
          <li>
            HTTP 요청 메시지 바디 조회
            <ul>
              <li>
                <a href="/request-param?username=hello&age=20"
                  >GET - 쿼리 파라미터</a
                >
              </li>
              <li><a href="/basic/hello-form.html">POST - HTML Form</a></li>
              <li>HTTP API - MessageBody -> Postman 테스트</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        HttpServletResponse
        <ul>
          <li><a href="/response-header">기본 사용법, Header 조회</a></li>
          <li>
            HTTP 응답 메시지 바디 조회
            <ul>
              <li><a href="/response-html">HTML 응답</a></li>
              <li><a href="/response-json">HTTP API JSON 응답</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </body>
</html>
```

<br>

> 이제부터 공부할 내용들이 목록화 되어 렌더링 된 것을 확인할 수 있다.

![](/assets/images/2025/2025-02-21-08-58-36.png)

<br><br>

# 3. HttpServletRequest

## 3.1 개요

> HTTP 요청 메시지를 개발자가 직접 파싱해서 사용해도 되지만, 매우 불편하다.

서블릿은 개발자가 HTTP 요청 메시지를 편리하게 사용할 수 있도록 개발자 대신에 HTTP 요청 메시지를 파싱한다. 그리고 그 결과를 `HttpServletRequest` 객체에 담아서 제공한다.

<br>

> HttpServletRequest를 사용하면 다음과 같은 HTTP 요청 메시지를 편리하게 조회할 수 있다.

```java
// HTTP 요청 메시지
/*  START LINE */
POST /save HTTP/1.1

/* 헤더  */
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded

/* 바디 */
username=kim&age=20
```

- START LINE
  - HTTP 메소드
  - URL
  - 쿼리 스트링
  - 스키마, 프로토콜
- 헤더
  - 헤더 조회
- 바디
  - form 파라미터 형식 조회
  - message body 데이터 직접 조회

<br>

> HttpServletRequest 객체는 추가로 여러가지 부가기능도 함께 제공한다.

① 임시 저장소 기능

- 해당 HTTP 요청이 시작부터 끝날 때까지 유지되는 임시 저장소 기능
  - 저장: `request.setAttribute(name, value)`
  - 조회: `request.getAttribute(name)`

<br>

② 세션 관리 기능

`request.getSession(create: true)`

<br>

> 중요⭐ (영한 강사님의 말씀 👨‍🏫💬)

HttpServletRequest, HttpServletResponse를 사용할 때 가장 중요한 점은 이 객체들이 HTTP 요청 메시지, HTTP 응답 메시지를 편리하게 사용하도록 도와주는 객체라는 점이다.

따라서 이 기능에 대해서 깊이있는 이해를하려면 HTTP 스펙이 제공하는 요청, 응답 메시지 자체를 이해해야 한다.

웹 어플리케이션을 깊이 있게 이해하기 위해 HTTP에 대해 이해하는 것이 중요하다.

<br>

## 3.2 기본 사용법

> `hello/servlet/basic`에 `request`라는 패키지를만든 후. `RequestHeaderServlet` 클래스를 만들자.

💡 Override 메서드 생성 단축키: `Ctrl + O`를 눌러 자물쇠 있는 service 메서드를 선택<br>
(단축키 확인: 설정 > Keymap > Override Methods )

### 3.2.1 start line 정보 출력

```java
package hello.servlet.basic.request;

// http://localhost:8080/request-header?username=hello
@WebServlet(name = "requestHeaderServlet", urlPatterns = "/request-header")
public class RequestHeaderServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        printStartLine(request);
    }

    // Start line 정보 출력
    private void printStartLine(HttpServletRequest request) {
        System.out.println("--- REQUEST-LINE - start ---");

        System.out.println("request.getMethod() = " + request.getMethod()); // GET
        System.out.println("request.getProtocol() = " + request.getProtocol()); // HTTP/1.1
        System.out.println("request.getScheme() = " + request.getScheme()); // http
        System.out.println("request.getRequestURL() = " + request.getRequestURL()); // http://localhost:8080/request-header
        System.out.println("request.getRequestURI() = " + request.getRequestURI()); // /request-header
        System.out.println("request.getQueryString() = " + request.getQueryString()); // username=hello
        System.out.println("request.isSecure() = " + request.isSecure()); // HTTPS 사용 여부

        System.out.println("--- REQUEST-LINE - end ---");
        System.out.println();
    }
}
```

![](/assets/images/2025/2025-02-21-13-20-17.png)

<br>

### 3.2.2 Header 정보 출력

> 모든 Header 정보를 출력해보자

```java
package hello.servlet.basic.request;


import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

// http://localhost:8080/request-header?username=hello
@WebServlet(name = "requestHeaderServlet", urlPatterns = "/request-header")
public class RequestHeaderServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        printStartLine(request);
        printHeaders(request); // 추가
    }

    // Start line 정보 출력
    private void printStartLine(HttpServletRequest request) {
    }

    // Header 모든 정보 출력
    private void printHeaders(HttpServletRequest request) {
        System.out.println("--- Headers - start ---");

        /* 옛날 스타일
         Enumeration<String> headerNames = request.getHeaderNames();
         while (headerNames.hasMoreElements()) {
         String headerName = headerNames.nextElement();
         System.out.println(headerName + ": " + request.getHeader(headerName));
         }
        */

        request.getHeaderNames().asIterator()
                .forEachRemaining(headerName -> System.out.println(headerName + ": " + request.getHeader(headerName)));
        System.out.println("--- Headers - end ---");
        System.out.println();
    }
}
```

![](/assets/images/2025/2025-02-21-13-26-56.png)

`HttpServletRequest`에는 별도로 `getHeaderValue` 같은 메서드가 없고, 대신 `getHeader(String name)` 메서드를 사용하여 특정 헤더의 값을 가져오는 것이다.

<br>

> 🤚 문법 짚고 넘어가기!

1. `request.getHeaderNames()`로 모든 헤더 이름들을 가져온다.
2. `asIterator()`를 사용해 이 헤더들을 순회할 수 있는 Iterator(순회 도구)로 변환한다.
3. `forEachRemaining`는 Iterator에 남아있는 모든 요소에 대해 지정된 동작(여기서는 람다 표현식)을 실행한다.
   - `headerName`는 람다 표현식에서 사용자가 지정한 매개변수 이름으로, Iterator가 반환하는 각 헤더 이름을 담기 위해 사용
4. 람다 표현식은 각 헤더 이름을 받아 "헤더 이름: 헤더 값" 형태로 출력한다.
   - e.g., HTTP 요청에 `Content-Type`이라는 헤더가 있고 값이 `text/html`이면, 출력은 `Content-Type: text/html`처럼 나타난다.

<br>

### 3.2.3 Header 편리한 조회

```java
// Header 편리한 조회
private void printHeaderUtils(HttpServletRequest request) {
    System.out.println("--- Header 편의 조회 start ---");

    // Host 정보 조회
    System.out.println("[Host 편의 조회]");
    System.out.println("request.getServerName() = " + request.getServerName()); // Host 헤더
    System.out.println("request.getServerPort() = " + request.getServerPort()); // Host 헤더
    System.out.println();

    // Accept-Language 조회
    System.out.println("[Accept-Language 편의 조회]");
    request.getLocales().asIterator()
            .forEachRemaining(locale -> System.out.println("locale = " + locale));
    System.out.println("request.getLocale() = " + request.getLocale());
    System.out.println();

    // Cookie 조회
    System.out.println("[Cookie 편의 조회]");
    // getCookies()는 쿠키가 없으면 null을 반환
    if (request.getCookies() != null) {
        // 향상된 forans: 배열 request.getCookies()의 각 요소를 cookie 변수에 하나씩 담아서 사용
        for (Cookie cookie : request.getCookies()) {
            System.out.println(cookie.getName() + ": " + cookie.getValue());
        }
    }
    System.out.println();

    // Content 정보 조회
    System.out.println("[Content 편의 조회]");
    System.out.println("request.getContentType() = " + request.getContentType());
    System.out.println("request.getContentLength() = " + request.getContentLength());
    System.out.println("request.getCharacterEncoding() = " + request.getCharacterEncoding());

    System.out.println("--- Header 편의 조회 end ---");
    System.out.println();
}
```

![](/assets/images/2025/2025-02-21-13-35-22.png)

<br>

> 아래와 같이 Post man을 통해 데이터를 보내면 정상적으로 Header Post 요청이 처리된 것을 확인할 수 있다.

GET -> `http://localhost:8080/request-header`

![](/assets/images/2025/2025-02-21-13-43-51.png)

![](/assets/images/2025/2025-02-21-13-43-10.png)

<br>

### 3.2.4 기타 정보 조회

> 기타 정보는 HTTP 메시지의 정보는 아니다

```java
// 기타 정보 조회
private void printEtc(HttpServletRequest request) {
    System.out.println("--- 기타 조회 start ---");

    // Remote 정보 조회
    System.out.println("[Remote 정보]");
    System.out.println("request.getRemoteHost() = " + request.getRemoteHost()); // 클라이언트 호스트명
    System.out.println("request.getRemoteAddr() = " + request.getRemoteAddr()); // 클라이언트 IP 주소
    System.out.println("request.getRemotePort() = " + request.getRemotePort()); // 클라이언트 포트 번호
    System.out.println();

    // Local 정보 조회
    System.out.println("[Local 정보]");
    System.out.println("request.getLocalName() = " + request.getLocalName()); // 서버 호스트명
    System.out.println("request.getLocalAddr() = " + request.getLocalAddr()); // 서버 IP 주소
    System.out.println("request.getLocalPort() = " + request.getLocalPort()); // 서버 포트 번호

    System.out.println("--- 기타 조회 end ---");
    System.out.println();
}
```

![](/assets/images/2025/2025-02-21-13-47-11.png)

<br><br>

# 4. HTTP 요청 데이터

지금까지 HttpServletRequest를 통해서 HTTP 메시지의 start-line, header 정보 조회 방법을 이해했다.

이제 본격적으로 HTTP 요청 데이터를 어떻게 조회하는지 알아보자.

 <br>

## 4.1 개요

> HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 방법을 알아보자.

주로 다음 3가지 방법을 사용한다.

<br>

> ① GET - 쿼리 파라미터

- `/url?username=hello&age=20`
- 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
- e.g., 검색, 필터, 페이징등에서 많이 사용하는 방식

<br>

> ② POST - HTML Form

- content-type: `application/x-www-form-urlencoded`
- 메시지 바디에 쿼리 파리미터 형식으로 전달 `username=hello&age=20`
- e.g., 회원 가입, 상품 주문, HTML Form 사용

![](/assets/images/2025/2025-02-21-13-52-57.png)

<br>

> ③ HTTP message body에 데이터를 직접 담아서 요청

- HTTP API에서 주로 사용, JSON, XML, TEXT
- 데이터 형식은 주로 JSON 사용
- POST, PUT, PATCH

<br>

## 4.2 GET 쿼리 파라미터

> 아래 데이터를 메시지 바디 없이, URL의 **쿼리 파라미터**를 사용해 클라이언트에서 서버로 전송해보자.

- 전달 데이터
  - `username=hello`
  - `age=20`

<br>

> 쿼리 파라미터는 URL에 다음과 같이 `?` 를 시작으로 보낼 수 있다. 추가 파라미터는 `&` 로 구분하면 된다.

`http://localhost:8080/request-param?username=hello&age=20`

<br>

`hello.servlet.basic.request`에 `RequestParamServlet`을 생성하자

```java
package hello.servlet.basic.request;


import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

/**
 * 1. 파라미터 전송 기능
 *    예) http://localhost:8080/request-param?username=hello&age=20
 *
 * 2. 동일한 파라미터 전송 가능
 *    예) http://localhost:8080/request-param?username=hello&username=kim&age=20
 */
@WebServlet(name = "requestParamServlet", urlPatterns = "/request-param")
public class RequestParamServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        System.out.println("[전체 파라미터 조회] - start");

        // 모든 요청 파라미터 출력
        request.getParameterNames().asIterator()
                .forEachRemaining(paramName ->
                        System.out.println(paramName + " = " + request.getParameter(paramName))
                );

        System.out.println("[전체 파라미터 조회] - end");
        System.out.println();

        // 단일 파라미터 조회
        System.out.println("[단일 파라미터 조회]");
        String username = request.getParameter("username");
        System.out.println("request.getParameter(\"username\") = " + username);
        String age = request.getParameter("age");
        System.out.println("request.getParameter(\"age\") = " + age);
        System.out.println();

        // 동일한 이름을 가진 복수 파라미터 조회
        System.out.println("[이름이 같은 복수 파라미터 조회]");
        System.out.println("request.getParameterValues(\"username\")");

        String[] usernames = request.getParameterValues("username");
        if (usernames != null) {
            for (String name : usernames) {
                System.out.println("username = " + name);
            }
        }

        response.getWriter().write("ok");
    }
}
```

> 실행 - 파라미터 전송

[http://localhost:8080/request-param?username=hello&age=20](http://localhost:8080/request-param?username=hello&age=20)

![](/assets/images/2025/2025-02-21-14-16-20.png)

<br>

> 실행 - 동일 파라미터 전송

이렇게 잘 사용하지않음

[http://localhost:8080/request-param?username=hello&username=kim&age=20](http://localhost:8080/request-param?username=hello&username=kim&age=20)

![](/assets/images/2025/2025-02-21-14-28-48.png)

<br>

> 복수 파라미터에서 단일 파라미터 조회

```
`username=hello&username=kim` 과 같이 파라미터 이름은 하나인데, 값이 중복이면 어떻게 될까?
```

- request.getParameter() 는 하나의 파라미터 이름에 대해서 단 하나의 값만 있을 때 사용해야 한다. 지금처럼 중복일 때는 `request.getParameterValues()` 를 사용해야 한다.
- 참고로 이렇게 중복일 때 `request.getParameter()` 를 사용하면 `request.getParameterValues()` 의 첫번째 값을 반환한다.

<br>

## 4.3 POST HTML Form

> 이번에는 HTML의 Form을 사용해서 클라이언트에서 서버로 데이터를 전송해보자.

주로 회원 가입, 상품 주문 등에서 사용하는 방식이다.

<br>

> 특징

- content-type: `application/x-www-form-urlencoded`
- 메시지 바디에 쿼리 파리미터 형식으로 데이터를 전달한다. `username=hello&age=20`

<br>

> `src/main/webapp/basic/hello-form.html` 생성

```html
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
  </head>
  <body>
    <form action="/request-param" method="post">
      username: <input type="text" name="username" /> age:
      <input type="text" name="age" />
      <button type="submit">전송</button>
    </form>
  </body>
</html>
```

[http://localhost:8080/basic/hello-form.html](http://localhost:8080/basic/hello-form.html) 실행해보자 (서버 재시작)

<br>

> POST의 HTML Form을 전송하면 웹 브라우저는 다음 형식으로 HTTP 메시지를 만든다. (웹 브라우저 개발자 모드 확인)

- 요청 URL: [http://localhost:8080/request-param](http://localhost:8080/request-param)
- content-type: `application/x-www-form-urlencoded`
- message body: `username=hello&age=20`

<br>

> ·application/x-www-form-urlencoded· 형식은 앞서 GET에서 살펴본 쿼리 파라미터 형식과 같다. 따라서 쿼리 파라미터 조회 메서드를 그대로 사용하면 된다.

- 클라이언트(웹 브라우저) 입장에서는 두 방식에 차이가 있지만, 서버 입장에서는 둘의 형식이 동일하므로, `request.getParameter()` 로 편리하게 구분없이 조회할 수 있다.
- 정리하면 `request.getParameter()` 는 GET URL 쿼리 파라미터 형식도 지원하고, POST HTML Form 형식도 둘 다 지원한다.

<br>

> 참고

- content-type은 HTTP 메시지 바디의 데이터 형식을 지정한다.
  - **GET URL 쿼리 파라미터 형식**으로 클라이언트에서 서버로 데이터를 전달할 때는 HTTP 메시지 바디를 사용하지 않기 때문에 content-type이 없다.
  - **POST HTML Form 형식**으로 데이터를 전달하면 HTTP 메시지 바디에 해당 데이터를 포함해서 보내기 때문에 바디에 포함된 데이터가 어떤 형식인지 content-type을 꼭 지정해야 한다.
- 이렇게 폼으로 데이터를 전송하는 형식을 `application/x-www-form-urlencoded` 라 한다.

<br>

### 4.3.1 Postman을 사용한 테스트

> 이런 간단한 테스트에 HTML form을 만들기는 귀찮다. 이때는 Postman을 사용하면 된다.

- POST 전송시
  - Body -> `x-www-form-urlencoded` 선택
  - Headers에서 `content-type: application/x-www-form-urlencoded` 로 지정된 부분 꼭 확인

![](/assets/images/2025/2025-02-21-14-53-52.png)

<br>

## 4.4 API 메시지 바디 - 단순 텍스트

> HTTP message body에 데이터를 직접 담아서 요청

- HTTP API에서 주로 사용, JSON, XML, TEXT
- 데이터 형식은 주로 JSON 사용
- POST, PUT, PATCH

<br>

> 먼저 가장 단순한 텍스트 메시지를 HTTP 메시지 바디에 담아서 전송하고, 읽어보자.

HTTP 메시지 바디의 데이터를 InputStream을 사용해서 직접 읽을 수 있다.

<br>

`hello.servlet.basic.request`에 `RequestBodyStringServlet` 생성

```java
package hello.servlet.basic.request;

import jakarta.servlet.ServletException;
import jakarta.servlet.ServletInputStream;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.util.StreamUtils;


import java.io.IOException;
import java.nio.charset.StandardCharsets;

/**
 * HTTP 요청 바디에서 문자열 데이터를 읽는 서블릿
 */
@WebServlet(name = "requestBodyStringServlet", urlPatterns = "/request-body-string")
public class RequestBodyStringServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // 요청 바디에서 데이터 읽기
        // HTTP 요청 바디의 내용을 바이트 스트림(ServletInputStream)으로 변환
        ServletInputStream inputStream = request.getInputStream();

        // 바이트 스트림 데이터를 UTF-8 문자열로 변환 (Spring의 StreamUtils 사용)
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        // 콘솔 출력
        System.out.println("messageBody = " + messageBody);

        // 응답 반환
        response.getWriter().write("ok");
    }
}
```

<br>

> 참고

inputStream은 byte 코드를 반환한다.

byte 코드를 우리가 읽을 수 있는 문자(String)로 보려면 문자표(Charset)를 지정해주어야 한다. 여기서는 UTF_8 Charset을 지정해주었다.

<br>

> Postman을 사용한 테스트

- 문자 전송
  - POST -> `http://localhost:8080/request-body-string`
  - content-type: `text/plain`
  - message body: `hello`
  - 결과: `messageBody = hello`

![](/assets/images/2025/2025-02-21-15-19-31.png)

<br>

## 4.5 API 메시지 바디 - JSON

> 이번에는 HTTP API에서 주로 사용하는 JSON 형식으로 데이터를 전달해보자.

- JSON 형식 전송
  - POST -> `http://localhost:8080/request-body-json`
  - content-type: `application/json`
  - message body: `{"username": "hello", "age": 20}`
  - 결과: `messageBody = {"username": "hello", "age": 20}`

<br>

> JSON 형식 파싱 추가

JSON 형식으로 파싱할 수 있게 객체를 하나 생성하자 (보통 JSON 형식을 객체로 바꿔서 사용)

`hello.servlet.basic.HelloData`

```java
package hello.servlet.basic;

import lombok.Getter;
import lombok.Setter;

@Getter @Setter
public class HelloData {
    private String username;
    private int age;
}
```

<br>

`hello.servlet.basic.request`에 `RequestBodyJsonServlet` 추가

```java
package hello.servlet.basic.request;

/**
 * JSON 요청을 처리하는 서블릿
 *
 * 요청 예시:
 * - URL: http://localhost:8080/request-body-json
 * - Content-Type: application/json
 * - Body: {"username": "hello", "age": 20}
 */
@WebServlet(name = "requestBodyJsonServlet", urlPatterns = "/request-body-json")
public class RequestBodyJsonServlet extends HttpServlet {

    // JSON 데이터를 객체로 변환하기 위한 ObjectMapper (Jackson 라이브러리 사용)
    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // 요청 바디(InputStream) 읽기
        ServletInputStream inputStream = request.getInputStream();
        String messageBody = StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);

        System.out.println("messageBody = " + messageBody);

        // JSON 데이터를 객체로 변환
        HelloData helloData = objectMapper.readValue(messageBody, HelloData.class);

        System.out.println("helloData.username = " + helloData.getUsername());
        System.out.println("helloData.age = " + helloData.getAge());

        // 응답 반환
        response.getWriter().write("ok");
    }
}
```

<br>

> 참고 (1)

- JSON 결과를 파싱해서 사용할 수 있는 자바 객체로 변환하려면 Jackson, Gson 같은 JSON 변환 라이브러리를 추가해서 사용해야 한다.
- 스프링 부트로 Spring MVC를 선택하면 기본으로 Jackson 라이브러리 ( ObjectMapper )를 함께 제공한다.

> 참고 (2)

- HTML form 데이터도 메시지 바디를 통해 전송되므로 직접 읽을 수 있다.
- 하지만 편리한 파리미터 조회 기능( request.getParameter(...) )을 이미 제공하기 때문에 파라미터 조회 기능을 사용하면 된다.

<br>

> Postman으로 실행해보자.

- POST -> `http://localhost:8080/request-body-json`
- content-type: `application/json` (Body raw, 가장 오른쪽에서 JSON 선택)
- message body: `{"username": "hello", "age": 20}`

![](/assets/images/2025/2025-02-21-15-27-26.png)

<br><br>

# 5. HttpServletResponse

## 5.1 HttpServletResponse 역할

> HTTP 응답 메시지 생성

- HTTP 응답코드 지정
- 헤더 생성
- 바디 생성

> 편의 기능 제공

Content-Type, 쿠키, Redirect

<br>

## 5.2 HttpServletResponse - 기본 사용법

`hello.servlet.basic.response.ResponseHeaderServlet`

```java
package hello.servlet.basic.response;

/**
 * HTTP 응답 헤더 설정 서블릿
 *
 * 요청 예시:
 * - URL: http://localhost:8080/response-header
 */
@WebServlet(name = "responseHeaderServlet", urlPatterns = "/response-header")
public class ResponseHeaderServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // [Status-Line] - HTTP 응답 상태 코드 설정 (200 OK)
        response.setStatus(HttpServletResponse.SC_OK);

        // [Response Headers] - 응답 헤더 설정
        response.setHeader("Content-Type", "text/plain;charset=utf-8");
        response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
        response.setHeader("Pragma", "no-cache");
        response.setHeader("my-header", "hello");

        // [Header 편의 메서드]
        content(response);
        cookie(response);
        redirect(response);

        // [Message Body] - 응답 본문 출력
        PrintWriter writer = response.getWriter();
        writer.println("ok");
    }

    /**
     * Content 편의 메서드
     */
    private void content(HttpServletResponse response) {
        //Content-Type: text/plain;charset=utf-8
        //Content-Length: 2
        //response.setHeader("Content-Type", "text/plain;charset=utf-8");
        response.setContentType("text/plain");
        response.setCharacterEncoding("utf-8");
        //response.setContentLength(2); //(생략시 자동 생성)
    }
s
    /**
     * 쿠키 편의 메서드
     */
    private void cookie(HttpServletResponse response) {
        // Set-Cookie: myCookie=good; Max-Age=600;
        // response.setHeader("Set-Cookie", "myCookie=good; Max-Age=600");
        Cookie cookie = new Cookie("myCookie", "good");
        cookie.setMaxAge(600); // 600초 (10분)
        response.addCookie(cookie);
    }

    /**
     * redirect 편의 메서드
     */
    private void redirect(HttpServletResponse response) throws IOException {
        // Status Code 302
        // Location: /basic/hello-form.html

        // response.setStatus(HttpServletResponse.SC_FOUND); // 302
        // response.setHeader("Location", "/basic/hello-form.html");
        response.sendRedirect("/basic/hello-form.html");
    }
}
```

![](/assets/images/2025/2025-02-21-15-43-40.png)

<br><br>

# 6. HTTP 응답 데이터

## 6.1 단순 텍스트, HTML

> HTTP 응답 메시지는 주로 다음 내용을 담아서 전달한다.

- 단순 텍스트 응답
  - 앞에서 살펴봄 ( `writer.println("ok");` )
- HTML 응답
- HTTP API - MessageBody JSON 응답

<br>

### 6.1.1 HttpServletResponse - HTML 응답

`hello.servlet.web.response.ResponseHtmlServlet`

```java
package hello.servlet.basic.response;

/**
 * HTML 응답을 생성하는 서블릿
 *
 * 요청 예시:
 * - URL: http://localhost:8080/response-html
 */
@WebServlet(name = "responseHtmlServlet", urlPatterns = "/response-html")
public class ResponseHtmlServlet extends HttpServlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // Content-Type 설정: HTML 문서 및 UTF-8 인코딩
        // Content-Type: text/html;charset=utf-8
        response.setContentType("text/html");
        response.setCharacterEncoding("utf-8");

        // HTML 응답 출력
        PrintWriter writer = response.getWriter();
        writer.println("<html>");
        writer.println("<body>");
        writer.println("    <div>안녕?</div>");
        writer.println("</body>");
        writer.println("</html>");
    }
}
```

- HTTP 응답으로 HTML을 반환할 때는 content-type을 text/html 로 지정해야 한다.
- 실행
  - [http://localhost:8080/response-html](http://localhost:8080/response-html)
  - 페이지 소스보기를 사용하면 결과 HTML을 확인할 수 있다.

![](/assets/images/2025/2025-02-21-16-00-22.png)

![](/assets/images/2025/2025-02-21-16-01-09.png)

<br>

```
응답 메시지의 시작라인(상태라인)은 포함하지 않은 이유?
```

시작라인은 서블릿 컨테이너(Tomcat, Jetty 등)에 의해 자동으로 생성되고 전송되기 때문에, 개발자가 직접 시작라인을 출력하거나 작성할 필요가 없다!

컨테이너가 기본적으로 `HTTP/1.1 200 OK` 등의 상태 정보를 포함한 전체 응답 메시지를 완성해 클라이언트에 전달한다.

<br>

### 6.1.2 HTTP 응답 데이터 - API JSON

`hello.servlet.web.response.ResponseJsonServlet`

```java
package hello.servlet.basic.response;

/**
 * JSON 응답을 생성하는 서블릿
 *
 * 요청 예시:
 * - URL: http://localhost:8080/response-json
 */
@WebServlet(name = "responseJsonServlet", urlPatterns = "/response-json")
public class ResponseJsonServlet extends HttpServlet {

    private final ObjectMapper objectMapper = new ObjectMapper();

    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

        // Content-Type 설정: JSON 및 UTF-8 인코딩
        response.setHeader("Content-Type", "application/json");
        response.setCharacterEncoding("utf-8");

        // JSON 데이터 생성
        HelloData data = new HelloData();
        data.setUsername("kim");
        data.setAge(20);

        // 객체를 JSON 문자열로 변환
        String result = objectMapper.writeValueAsString(data);

        // JSON 응답 출력
        response.getWriter().write(result);
    }
}
```

- HTTP 응답으로 JSON을 반환할 때는 content-type을 `application/json` 로 지정해야 한다.
- Jackson 라이브러리가 제공하는 `objectMapper.writeValueAsString()` 를 사용하면 객체를 JSON 문자로
  변경할 수 있다.
- 실행
  - [http://localhost:8080/response-json](http://localhost:8080/response-json)

![](/assets/images/2025/2025-02-21-16-05-36.png)

<br>

> 참고 (중요x)

- `application/json` 은 스펙상 utf-8 형식을 사용하도록 정의되어 있다. 그래서 스펙에서 charset=utf-8 과 같은 추가 파라미터를 지원하지 않는다.
- 따라서 `application/json` 이라고만 사용해야지`application/json;charset=utf-8` 이라고 전달하는 것은 의미 없는 파라미터를 추가한 것이 된다.
- `response.getWriter()`를 사용하면 추가 파라미터를 자동으로 추가해버린다. 이때는
- `response.getOutputStream()`으로 출력하면 그런 문제가 없다

<br>
