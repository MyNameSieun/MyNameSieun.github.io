---
title: "[Spring] 김영한 스프링 MVC 1편 정리 #1 - 스프링 웹 MVC"
categories: [Spring]
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

# 1. 웹 서버, 웹 애플리케이션 서버 (WAS)

## 1.1 모든 것이 HTTP

> HTTP는 웹 기반으로 동작, 모든 것이 HTTP

- HTML, TEXT
- 이미지, 음성, 영상, 파일
- JSON, XML (API)
- 등등...

거의 모든 형태의 데이터 전송 가능

<br>

## 1.2 웹 서버와 웹 애플리케이션 서버 (WAS)

> 웹 서버

클라이언트(웹 브라우저)로부터의 HTTP 요청을 받아 **정적인 콘텐츠**(HTML, 이미지, CSS 등)를 제공하는 소프트웨어

![](/assets/images/2025/2025-02-20-18-51-02.png)

- HTTP 기반으로 동작
- 정적 리소스 제공
- e.g., NGINX, APACHE

<br>

> 웹 애플리케이션 서버 (WAS, Web Application Server)

**웹서버의 기능을 포함**하면서도 **동적인 웹 애플리케이션을 실행**하고, 클라이언트(웹 브라우저)의 요청을 처리하는 소프트웨어

![](/assets/images/2025/2025-02-20-18-51-14.png)

- HTTP 기반으로 동작
- 정적 리소스, 애플리케이션 로직 모두 제공 가능

```
동적인 웹 애플리케이션을 어떻게 실행할까?
```

- 클라이언트 요청을 받고 적절한 서버 측 **프로그램** (e.g., **서블릿**, JSP, 스프링 MVC 등)을 실행
- 즉, **프로그램 코드를 실행해서 애플리케이션 로직 실행**
- 대표적인 WAS 종류.,

  | WAS 종류       | 설명                                            |
  | -------------- | ----------------------------------------------- |
  | **Tomcat**     | 가장 많이 사용되는 서블릿 컨테이너 (가벼운 WAS) |
  | JBoss(WildFly) | 대규모 엔터프라이즈 웹 애플리케이션용 WAS       |
  | WebLogic       | Oracle에서 만든 강력한 WAS (기업용)             |
  | WebSphere      | IBM에서 만든 기업용 WAS                         |

<br>

> 웹 서버 vs WAS (웹 애플리케이션 서버)

- 웹 서버는 정적 리소스 (파일), WAS는 애플리케이션 로직
- WAS는 애플리케이션 코드를 실행하는데 더 특화

<br>

## 1.3 웹 시스템 구성

### 1.3.1 WAS, DB

> 웹 시스템은 WAS, DB만으로 구성 가능

- WAS는 정적 리소스, 애플리케이션 로직 모두 제공하기 떄문
- 하지만, WAS가 너무 많은 역할을 담당하면 아래와 같은 문제점이 있음
  - 서버 과부화 우려
  - ⭐ 가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수 있음

<br>

### 1.3.2 WEB, WAS, DB

> 따라서 일반적으로 아래와 같은 웹 시스템 구성

![](/assets/images/2025/2025-02-20-18-56-35.png)

- 정적 리소스는 웹 서버가 처리
- 웹 서버는 애플리케이션 로직같은 **동적인 처리가 필요하면 WAS에 요청을 위임**
- WAS는 중요한 애플리케이션 로직 처리 전담

<br>

> 위와 같이 웹 시스템을 구성했을 때 장점

- 효율적인 리소스 관리
  - 정적 리소스가 많이 사용되면 Web 서버 증설
  - 애플리케이션 리소스가 많이 사용되면 WAS 증설
- 오류 화면 제공 가능
  - 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음
  - WAS, DB 장애시 WEB서버가 오류 화면 제공 가능

<br><br>

# 2. 서블릿

## 2.1 서블릿이란?

> Java를 사용할 때 웹 페이지를 동적으로 생성하는 서버측 프로그램. 웹 요청과 응답의 흐름을 간단한 메서드 호출만으로 체계적으로 다룰 수 있게 해줌 (WAS 내부에서 실행)

- 서블릿이 없으면? 웹 애플리케이션을 직접 구현해야함
- 서블릿을 지원하는 WAS를 사용하면? 개발자는 의미 있는 비즈니스 로직을 작성하는 데 집중할 수 있음.<br><br>![](/assets/images/2025/2025-02-20-19-10-39.png)

💡 서블릿은 웹 애플리케이션의 기능을 구현하는 **프로그램**(코드)이고, WAS는 그 코드를 실행하고 관리하는 **서버**(소프트웨어)

<br>

## 2.2 특징

```java
@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {

  @Override
  protected void service(HttpServletRequest request, HttpServletResponse response){
  //애플리케이션 로직
  }
}
```

- `urlPatterns(/hello)`의 URL이 호출되면 서블릿 코드가 실행
- HTTP 요청 정보를 편리하게 사용할 수 있는 `HttpServletRequest`
- HTTP 응답 정보를 편리하게 제공할 수 있는 `HttpServletResponse`
- 개발자는 HTTP 스펙을 매우 편리하게 사용

<br>

## 2.3 HTTP 요청, 응답 흐름

![](/assets/images/2025/2025-02-20-19-13-26.png)

1. HTTP 요청시, WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출
2. 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
3. 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력
4. WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성

<br>

## 2.4 서블릿 컨테이너

> 서블릿 컨테이너는 서블릿이라는 자바 프로그램을 실행하고 관리하여 클라이언트 요청에 따른 동적 웹 페이지를 만들어주는 환경을 의미한다.

- 즉, 톰캣처럼 **서블릿을 지원하는 WAS를 서블릿 컨테이너**라고 한다.
- 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 **생명주기를 관리**한다.
- 서블릿 객체는 **싱글톤으로 관리**한다. (⚠️ 공유 변수 사용 주의)
- JSP도 서블릿으로 변환되어서 사용한다.
- ⭐⭐ 동시 요청을 위한 **멀티 쓰레드 처리를 지원**한다. (따라서 개발자는 신경 쓰지 않아도 됨)

```CSS
Q.
JSP 컨테이너가 따로 있을까?

A.
- JSP 컨테이너라는 개념은 존재하지만,  JSP는 실행 전에 서블릿으로 변환되므로, 서블릿 컨테이너가 JSP도 관리하는 것과 같다.
- 따라서 JSP 컨테이너보다는 "서블릿 컨테이너가 JSP까지 포함해서 실행한다"고 보는 것이 더 정확하다.
```

<br>

서블릿 지원하는 WAS 안에 서블릿 컨테이너가 존재

![](/assets/images/2025/2025-02-20-19-24-13.png)

<br><br>

# 3. 동시 요청 - 멀티 쓰레드⭐⭐

## 3.1 서블릿과 WAS 요청 처리 흐름

> 웹 브라우저(클라이언트)가 요청을 보내면, WAS가 이를 받아서 서블릿을 실행하는 방식으로 동작 (with GPT)

![](/assets/images/2025/2025-02-20-19-30-09.png)

- 1️⃣ 클라이언트(웹 브라우저)가 HTTP 요청 전송 (e.g., `http://example.com/login`)
- 2️⃣ 웹 서버 또는 WAS가 요청을 받음
  - 요청이 정적 파일(HTML, CSS, JS 등)이면 웹 서버에서 직접 처리 후 응답을 반환.
  - 동적 요청(서블릿, JSP, Spring 등)이면 WAS로 전달됨.
- 3️⃣ WAS가 TCP/IP 연결을 맺고 서블릿 호출
  - WAS가 클라이언트와 TCP/IP 연결을 생성하고, HTTP 요청을 해석하여 적절한 서블릿을 찾음.
- 4️⃣ 서블릿이 요청을 처리 (service(), doGet(), doPost())
  - 서블릿이 처음 요청받으면 객체를 생성하고(init() 호출), 이후 요청마다 service() 메서드 실행.
  - 즉, 메서드를 호출하여 요청 처리
- 5️⃣ 서블릿이 응답을 생성하여 WAS에 반환
  - 서블릿이 HTML, JSON, XML 등의 응답 데이터를 생성.
  - HttpServletResponse 객체를 통해 클라이언트에게 응답을 반환.
- 6️⃣ WAS가 응답을 클라이언트에게 전달
  - WAS는 HTTP 응답을 TCP/IP 프로토콜을 통해 클라이언트(웹 브라우저)로 전송.
  - 클라이언트는 응답을 받아 웹 브라우저에 표시.

```
그럼 서블릿 객체는 누가 호출하는거지?
```

<br>

## 3.2 쓰레드

- 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 쓰레드!
- 자바 메인 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행된다.
- 쓰레드는 한번에 하나의 코드 라인만 수행하며, 동시 처리가 필요하면 쓰레드를 추가로 생성하면 된다.

<br>

> 만약, 다중 요청일 때 쓰레드를 하나 사용하면?

![](/assets/images/2025/2025-02-20-19-37-13.png)

요청이 처리 될 때까지 처리 지연이 발생할 것이다.

<br>

> 그렇다면 요청마다 쓰레드를 생성하면?

![](/assets/images/2025/2025-02-20-19-37-55.png)

- 동시 요청을 처리할 수 있으나, 고객이 올 때마다 쓰레드를 생성하면 응답 속도가 늦어진다.
- 또한, 쓰레드 생성에 제한이 없어 고객 요청이 너무 많이 오면, CUP, 메모리 임계점을 넘어서 서버가 죽을 수 있다.

<br>

💡 따라서 요청마다 쓰레드 생성하는 단점을 해결하기 위해 **쓰레드 풀**을 사용한다.

<br>

## 3.3 쓰레드 풀

![](/assets/images/2025/2025-02-20-19-41-30.png)

> 특징

- 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다.
- 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리한다. (톰캣은 최대 200개 기본 설정 (변경 가능))

<br>

> 사용

- 쓰레드가 필요하면, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용한다.
- 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다.
- 최대 쓰레드가 모두 사용중이어서 쓰레드 풀에 쓰레드가 없으면?
  - 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정할 수 있다.

<br>

> 장점

- 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답 시간이 빠르다.
- 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다

<br>

> 유의점

- WAS의 주요 튜닝 포인트는 최대 쓰레드의 수이다.
  - 너무 낮게 설정하면 -> 동시 요청이 많을 때, 클라이언트 금방 응답 지연
  - 너무 높게 설정하면 -> 동시 요청이 많을 때, CPU, 메모리 임계점 초과로 서버 다운

<br>

> 💡 따라서 적정 숫자의 쓰레드 풀을 설계하는 게 중요하다!

적정 숫자는 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다르다.

<br>

## 3.4 WAS의 멀티 쓰레드 지원 핵심

> ⭐ 멀티 쓰레드에 대한 부분은 WAS가 처리하므로, 개발자는 멀티 쓰레드 관련 코드를 신경쓰지 않아도 된다.

- 개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발할 수 있다.
- 멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)은 주의해서 사용해야 한다.

<br><br>

# 4. HTML, HTTP API

> 개발자는 서비스를 제공할 때 3가지를 고민해야 한다.

1. 정적 리소스
2. 동적으로 제공하는 HTML 페이지
3. HTML API

| 구분      | 정적 리소스                  | 동적 HTML 페이지             | HTML API (REST API)       |
| --------- | ---------------------------- | ---------------------------- | ------------------------- |
| 제공 방식 | 파일 그대로 반환             | 요청에 따라 서버가 HTML 생성 | JSON, XML **데이터** 반환 |
| 서버 역할 | 웹 서버(Apache, Nginx 등)    | WAS(Tomcat, JBoss 등)        | WAS(Spring, Node.js 등)   |
| 예제 요청 | index.html                   | user/1                       | api/user/1                |
| 사용 목적 | CSS, JS, 이미지, 동영상 제공 | 웹 페이지 동적 생성          | API 데이터 제공           |

<br>

## 4.1 정적 리소스

> HTML, CSS, JS, 이미지 같은 정적인 파일을 그대로 웹 브라우저에게 제공

![](/assets/images/2025/2025-02-21-07-07-12.png)

<br>

## 4.2 HTML 페이지

> 서버에서 동적으로 필요한 HTML 파일을 생성한 후 전달

![](/assets/images/2025/2025-02-21-07-09-17.png)

<br>

## 4.3 HTML API (REST API)

> HTML이 아니라 데이터를 전달, 주로 JSON 형식을 사용

![](/assets/images/2025/2025-02-21-07-10-24.png)

<br>

> 다양한 시스템에서 호출되며, 데이터만 주고 받음

- UI 화면이 필요하면, 클라이언트가 별도 처리
- 앱, 웹 클라이언트, 서버 to 서버

![](/assets/images/2025/2025-02-21-07-11-47.png)

<br><br>

# 5. CSR과 SSR

📌 자세한 내용은 [[Rendering 기법(CSR, SSG, ISR, SSR, Hydration)]](https://mynamesieun.github.io/next.js/2-Rendering-%EA%B8%B0%EB%B2%95(CSR,-SSG,-ISR,-SSR,-Hydration)/) 포스팅을 참고하자.

<br>

## 5.1 SSR - 서버 사이드 렌더링

- HTML 최종 결과를 **서버에서 만들어서** 웹 브라우저에 전달
- 주로 정적인 화면에 사용
- 관련기술: JSP, 타임리프 -> 백엔드 개발자

<br>

## 5.2 CSR - 클라이언트 사이드 렌더링

- HTML 결과를 자바스크립트를 사용해 **웹 브라우저에서 동적으로 생성**해서 적용
- 주로 동적인 화면에 사용, 웹 환경을 마치 앱 처럼 필요한 부분부분 변경할 수 있음
- e.g., 구글 지도, Gmail, 구글 캘린더
- 관련기술: React, Vue.js -> 웹 프론트엔드 개발자

<br>
