---
title: "[React P.J, ForYou] 편지 등록, 삭제, 수정 기능 구현 #5"
categories: [Project]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

# 1. 편지 등록 기능

초기 코드

```js
function AddForm() {
  return (
    <AddFormContainer>
      <AddFormTitle>편지를 작성해주세요.</AddFormTitle>
      <form>
        <AddFormBox>
          <p>닉네임</p>
          <input
            type="text"
            placeholder="최대 20글자까지 작성할 수 있습니다."
            maxLength={20}
          />
        </AddFormBox>
        <AddFormBox>
          <p>내용</p>
          <textarea
            placeholder="최대 600글자까지 작성할 수 있습니다."
            maxLength={600}
          ></textarea>
        </AddFormBox>
        <AddFormBox>
          <AddFormButton>편지 등록</AddFormButton>
        </AddFormBox>
      </form>
    </AddFormContainer>
  );
}
```

<br>

## 1.1 uuid 사용하기

고유한 id 값을 생성하기 위해 uuid라는 라이브러리를 사용할 것이다.

```
yarn add uuid
```

```js
import { v4 as uuid } from "uuid";

const newLetter = {
  id: uuid(),
};
```

<br>

## 1.2 기능 구현하기

① 기존에 있는 state를 복제해서 새로운 state를 생성하는 방식으로 등록 기능을 구현해야 한다.<br> → 그렇다면 어떤 state를 복제해야하지?

<br>

② fakeData가 들어있는 state를 새로 생성하여 PropsDrilling으로 LetterList와 AddForm에 넘겨주자!

```js
// Home.jsx
...
import fakeData from "fakeData.json"; // import

function Home() {
  const [activeTab, setActiveTab] = useState("토토로");
  const [letters, setLetters] = useState(fakeData); // state 생성

  return (
    <HomeLayout>
      <Navbar />
      <HomeRow>
        <Tabs activeTab={activeTab} setActiveTab={setActiveTab} />
        <HomeCol>
          <AddForm activeTab={activeTab} setLetters={setLetters} />
          <LetterList activeTab={activeTab} letters={letters} />
        </HomeCol>
      </HomeRow>
    </HomeLayout>
  );
}
...
```

<br>

③ LetterList에 fakeData를 새로 생성한 state인 letters로 바꿔주자!

```js
// LetterList.jsx
...
const filteredLetters = letters.filter(
  (letter) => letter.writedTo === activeTab
);
...
```

<br>

④ 그리고 props로 전달 받은 값으로 편지 등록 로직을 추가하자

```js
// AddForm.jsx
...
import { useState } from "react";
import { v4 as uuid } from "uuid";

function AddForm({ activeTab, setLetters }) {
  const [nickname, setNickName] = useState("");
  const [content, setContent] = useState("");

  const onAddLetter = (e) => {
    e.preventDefault();
    if (!nickname) {
      return alert("닉네임을 입력해주세요");
    }
    if (!content) {
      return alert("내용을 입력해주세요.");
    }

    const newLetter = {
      id: uuid(),
      createdAt: new Date(),
      nickname,
      avatar: null,
      content,
      writedTo: activeTab,
    };

    setLetters((prevLetters) => [...prevLetters, newLetter]);
    setNickName("");
    setContent("");
  };
  return (
    <AddFormContainer>
      <AddFormTitle>편지를 작성해주세요.</AddFormTitle>

      <form onSubmit={onAddLetter}>
        <AddFormBox>
          <p>닉네임</p>
          <input
            type="text"
            placeholder="최대 20글자까지 작성할 수 있습니다."
            maxLength={20}
            value={nickname}
            onChange={(e) => setNickName(e.target.value)}
          />
        </AddFormBox>
        <AddFormBox>
          <p>내용</p>
          <textarea
            placeholder="최대 600글자까지 작성할 수 있습니다."
            maxLength={600}
            value={content}
            onChange={(e) => setContent(e.target.value)}
          ></textarea>
        </AddFormBox>
        <AddFormBox>
          <AddFormButton>편지 등록</AddFormButton>
        </AddFormBox>
      </form>
    </AddFormContainer>
  );
}

...
```

<br>

## 1.3 상태 직접 업데이트 vs 콜백 함수 사용 비교

> 상태 직접 업데이트 vs 콜백 함수 사용 중 어떤게 더 효율적일까 궁금해졌다!

- 상태 직접 업데이트
  - `setState(newValue)`를 호출할 때 `newValue`가 이전 상태값에 의존하지 않는 경우 사용한다.<br><br>
- 콜백 함수 사용
  - `setState(prevState => newValue)` 형태로 사용되며, `prevState`는 현재의 상태를 참조한다.
  - **이전 상태값을 기반으로** 새 상태를 할당할 때 사용한다.

```js
function AddForm({ setLetters, activeTab }) {
  const [nickname, setNickName] = useState("");
  const [content, setContent] = useState("");

  const onAddLetter = (e) => {
  ...
    const newLetter = {
      id: uuid(),
      createdAt: new Date(),
      nickname,
      avatar: null,
      content,
      writedTo: activeTab,
    };
    setLetters([...letters, newLetter]); // 상태 직접 업데이트
    setLetters((prev) => [...prev, newLetter]); // 콜백 함수 사용

    setNickName("");
    setContent("");
  };
}
```

결론부터 말하면, 콜백 함수를 사용하는 것이 더 좋다고 한다.

<br>

> 콜백 함수를 사용하는 이유

- **배치 업데이트**
  - React는 여러 상태 업데이트를 배치로 처리하여 여러 setState 호출이 동시에 일어나더라도 이를 모아서 한 번에 처리함으로써 렌더링 횟수를 최소화하고 성능을 향상시킨다.
  - 따라서, setState를 호출하더라도 상태가 즉시 업데이트되지 않을 수 있다.
  - 즉, 연속적인 상태 업데이트가 필요한 경우, 콜백 함수를 사용하는 것이 안전하다.
    .<br><br>
- **안정성 보장**
  - 콜백 함수를 사용하면, 업데이트가 실행될 때 가장 최근의 상태값을 받아온다.
  - 따라서 동시에 여러 상태 업데이트가 일어나는 경우에도 정확한 값을 보장한다.

<br>

> 배치 업데이트 예시

```js
const [count, setCount] = useState(0);

setCount(count + 1); // count(0) + 1은 1, 1로 만드는 중...
setCount(count + 1); // 윗 줄의 상태 변경이 안 끝나서 아직 count는 0, count(0) + 1은 1, 1로 만드는 중...
setCount(count + 1); // 윗 줄과 윗윗줄의 상태 변경이 안 끝나서 아직 count는 0, count(0) + 1은 1, 1로 만드는 중...

// count = 1
```

1. `setState` 를 호출함과 동시에 많은 프로세스가 실행
2. 예를 들어 가상 DOM을 비교하고 리렌더링까지 ⇒ 렌더링 사이클
3. 렌더링 사이클이 끝나기 전에 다른 코드에서 상태를 변경하게 되면 해당 작업은 무시된다.

<br>

**이러한 이유 때문에 나는 콜백 함수를 사용하는 방식을 채택하였다! 🎯**

<br><br>

# 2. 편지 삭제 기능

아래와 같이 detail UI를 구성했다.

1. 삭제 버튼 클릭 시 즉시 삭제하기 보다는 사용자에게 확인받은 뒤 삭제처리 하도록 해주세요.

2. 삭제 확인 시 홈 화면으로 페이지 이동시켜 주세요.

3. 홈 화면에 남겨진 팬레터가 없을 경우, 해당 멤버에게 남겨진 팬레터가 없다는 문구를 보여주세요.

<br>

삭제 버튼을 클릭하면 편지가 삭제 되도록 구현해보자.

<br><br>

# 3. 편지 수정 기능

- 상세요구사항

  1. 수정버튼 클릭 시 수정 가능한 textarea 가 나오도록 합니다.

  2. 수정 가능 textarea가 나올 때 빈 입력란이 아니라 기존의 내용이 입력된 상태가 되도록 합니다.

  3. 아무런 수정사항 없이 수정완료 버튼을 클릭하면 수정처리하지 않고 사용자에게 “아무런 수정사항이 없습니다.” 라고 알림을 줍니다.

<br><br>
