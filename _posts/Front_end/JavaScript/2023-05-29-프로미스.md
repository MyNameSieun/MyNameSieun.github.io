---
title: "[JS] 프로미스"
categories: [JavaScript]
tag: [JavaScript]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

[[콜백함수]](https://mynamesieun.github.io/javascript/%ED%95%A8%EC%88%98/) 에 이어 작성하는 글입니다.
{: .notice--danger}

---

# 1 프로미스 개요

## 1.1 프로미스 개념

- 프로미스란, 비동기 처리에 대해, 처리가 끝나면 알려달라는 ‘약속’이다.

  - new 연산자로 호출한 Promise의 인자로 넘어가는 콜백은 바로 실행된다.
  - 그 내부의 resolve(또는 reject) 함수를 호출하는 구문이 있을 경우 resolve(또는 reject) 둘 중 하나가 실행되기 전까지는 다음(then), 오류(catch)로 넘어가지 않는다.
  - 따라서, 비동기작업이 완료될 때 비로소 <span style="color:indianred">resolve(성공), reject(실패)</span> 호출되게 된다.

- 즉, 프로미스를 사용하여 비동기 작업의 동기적 표현을 구현할 수 있는 것이다.

<br>

## 1.2 동기와 비동기

- 동기
  - 작업이 순차적으로 실행된다. 한 작업이 끝나야 다음 작업이 시작된다.
  - 즉, 동기적 처리는 기다리는 동안 아무 것도 할 수 없다. (멈춰있는 화면)
    <br> <br>
- 비동기
  - 작업이 동시에 실행될 수 있다. 한 작업이 끝나기를 기다리지 않고 다음 작업을 진행할 수 있다.
  - 아래 그림처럼 응답이 오지 않았음에도 요청을 동시 다발적으로 할 수 있다.
    <br> <br>
    ![](/assets/images/2024/2024-01-16-18-10-57.png)
    <br><br>

> 비동기 함수의 동기적 표현이 왜 필요할까?

① 외부 서버로부터 가져온 날씨 데이터를 화면에 뿌려주고 싶은 경우<br>
→ 외부 서버에서 날씨 데이터를 가져오는 작업은 시간이 걸릴 수 있으므로 이를 동기적으로 표현하려면 비동기 함수를 사용한다. 이때 화면에 데이터를 뿌리는 부분은 해당 비동기 함수 내에서 동기적으로 처리되어야 한다.
→ 즉, 비동기를 동기적으로 만들어 줘야만 순차 처리가 가능하다.

② 신용카드 이용 내역에 대한 메일 알림 서비스 신청한 경우, 신청내역 적재만 하고 사용자에게는 신청이 완료됐다고만 알려줌

- 알림 서비스 신청 후 내용 전송까지 5분 이상 소요된다고 가정
- 사용자에게는 “신청이 완료됐습니다. 5분 내로 발송됩니다.” 출력<br>
  → 비동기 작업의 완료를 기다리지 않고 사용자에게 빠른 응답을 보내기 위해 비동기 함수의 동기적 표현이 필요하다.

③ 5개의 외부 정보 사이트에서 데이터를 읽어온 후, 일괄로 내부 데이터베이스에 저장하는 경우<br>
→ 여러 외부 정보 사이트에서 데이터를 읽어오는 작업이 동시에 진행되므로, 각 사이트에서 데이터를 읽어오는 부분은 비동기적으로 처리된다. 그러나 모든 데이터를 읽어오고 나서 내부 데이터베이스에 저장하는 부분은 동기적으로 처리되어야 한다.<br><br>
![](/assets/images/2024/2024-01-16-19-28-53.png)

<br>

> 비동기 함수의 동기적 표현의 방법

- [then ~ catch](<https://mynamesieun.github.io/javascript/fetch()%ED%95%A8%EC%88%98%EB%A1%9C-HTTP-%EC%9A%94%EC%B2%AD%ED%95%98%EA%B8%B0/>) : 프로미스를 반환
- aync ~ await(try ~ catch)

<br><br>

# 2. 프로미스 사용하기

## 2.1 state(상태)

- 대기(Pending): 프로미스가 생성된 초기 상태

- 이행(Fulfilled): 프로미스가 성공적으로 완료된 상태이며 성공 리턴 값(resolve) 전달

- 거부(Rejected): 프로미스가 실패한 상태이며 실패 리턴 값(reject) 전달

<br>

## 2.1 프로미스 생성

> Producer (정보 제공)

- 프로미스는 클래스이기 때문에 new 라는 키워드를 사용해서 object를 생성할 수 있다.

```jsx
const promise = new Promise();
```

<br>

- 프로미스 생성자는 콜백 함수를 매개변수로 받는다. 이 콜백 함수는 두 개의 매개변수(resolve, reject)를 가진다.
- 이행단계일때 resolve를 통해 성공 리턴 값을 호출하며, 거부단계일 때 reject를 통해 실패 리턴 값을 호출한다.

```jsx
const promise = new Promise((resolve, reject) => {
  // 무거운 일들을 실행한다.
});
```

<br>

> 보통 프로미스 안에서 무거운 일들을 실행한다.

- 네트워크에서 데이터를 받아오거나 파일에서 큰 데이터를 읽어오는 과정은 시간이 많이 걸린다.
- 만약 동기적으로 이 과정들을 처리하게 되면 파일을 읽어오고 네트워크에서 데이터를 받아오는 동안 아무 동작도 수행할 수 없게 된다.
- 따라서 시간이 걸리는 일들은 프로미스를 만들어서 비동기적으로 처리하는 것이 좋다.

<br>

> 프로미스를 출력해보자

```jsx
const promise = new Promise((resolve, reject) => {
  console.log("출력"); // 출력
});
```

<br>

> 위 코드를 통해 알 수 있는 사실은 프로미스를 만드는 순간 우리가 전달한 executor라는 콜백 함수가 바로 실행되는 것을 확인할 수 있다.

- 위와 같은 식으로 작성하게 되면 사용자가 버튼을 눌렀을 때 네트워크 요청을 해야하는 경우 사용자가 요구하지도 않았는데 콜백 함수가 바로 실행이 되기때문에 문제가 발생할 수 있다.

<br>

> settimeout()을 이용해 원하는 콜백 함수를 2초 뒤에 실행시켜보자

```jsx
const promise = new Promise((resolve, reject) => {
  console.log("출력");
  setTimeout(() => {
    resolve("sieun");
  }, 2000);
});
```

resolve라는 콜백 함수를 호출하여 기능이 잘 수행됐을 때 "sieun"을 호출하게 하였다.

<br><br>

## 2.2 then

> Consumers(정보 이용)은 then, catch, finally를 이용해 값을 받아올 수 있다.

> Resolve(성공리턴값)호출 -> then으로 연결

then을 사용하여 프로미스가 정상적으로 완료가 되면 마지막에 최종적으로 resolve라는 콜백함수를 통해 전달한 값("sieun")이 value에 파라미터로 전달되어져서 들어오는 것을 볼 수 있다.

```jsx
// Producer
const promise = new Promise((resolve, reject) => {
  console.log("출력");
  setTimeout(() => {
    resolve("sieun");
  }, 2000);
});

// Consumers : then, catch, finally
promise.then((value) => {
  console.log(value); // (3초 뒤) "sieun"
});
```

![](https://velog.velcdn.com/images/sieunpark/post/de0206d6-c2a6-4412-9cfd-0f9396ba8c2d/image.png)

<br>

---

<br>

## ▷ catch

> Reject(실패리턴값)호출 -> catch로 연결

reject는 Error라는 object를 통해서 값을 전달한다. 어떤 에러가 발생했는지 이유를 잘 명시해서 작성해줘야한다.

```jsx
// Producer
const promise = new Promise((resolve, reject) => {
  console.log("출력");
  setTimeout(() => {
    //resolve("sieun");
    reject(new Error("네트워크 오류"));
  }, 2000);
});

// Consumers : then, catch, finally
promise.then((value) => {
  console.log(value);
});
```

"출력" 실행 후 3초 뒤 네트워크 오류가 발생하는 것을 알 수 있다.
![](https://velog.velcdn.com/images/sieunpark/post/98fbd574-bca9-4dff-80b2-47bd3ce96131/image.png)

<br>

catch를 사용해서 에러가 발생했을 때 어떻게 처리할 것인지 콜백함수를 등록해보자

```jsx
// Consumers : then, catch, finally
promise
  .then((value) => {
    console.log(value);
  })
  .catch((error) => {
    console.log(error);
  });
```

![](https://velog.velcdn.com/images/sieunpark/post/bdd9a880-4b18-4fee-9db0-5524284ebc69/image.png)

더 이상 에러가 발생하지 않고 우리가 받아온 에러가 console.log에 출력되는 것을 볼 수 있다.

<br>

> 위 과정은 Promise 체이닝을 통해 여러 개의 비동기 작업을 순차적으로 실행하고 결과를 처리한다.

- then호출 -> 프로미스 리턴 -> 리턴된 프로미스의 catch 등록

<br>

## ▷ 정리!

```jsx
// Producer
const promise = new Promise((resolve, reject) => {
  console.log("출력");
  setTimeout(() => {
    //resolve("sieun");
    reject(new Error("네트워크 오류"));
  }, 2000);
});

// Consumers : then, catch, finally
promise
  .then((value) => {
    console.log(value);
  })
  .catch((error) => {
    console.log(error);
  });
```

- 프로미스 오브젝트를 만들 때, 비동기적으로 수행하고 싶은 작업을 Producer 부분에 작성하고 나서,
- 성공적으로 실행이 됐다면 resolve를 통해 성공 리턴 값을 호출, 실패했다면 reject를 통해 실패 이유가 담긴 리턴값을 호출한다.
- 나중에 Consumers 부분에 프로미스를 이용해서 then과 catch를 이용해 성공한 값, 실패한 에러를 받아와서 원하는 방식으로 처리하는 것이다.

<br>

## ▷ Finally

> Finally 부분은 성공, 실패하던 상관없이 무조건 마지막에 호출된다.

```jsx
// Producer
const promise = new Promise((resolve, reject) => {
  console.log("출력");
  setTimeout(() => {
    resolve("sieun");
    //reject(new Error("네트워크 오류"));
  }, 2000);
});

// Consumers : then, catch, finally
promise
  .then((value) => {
    console.log(value);
  })
  .catch((error) => {
    console.log(error);
  })

  // finally 부분 추가로 작성
  .finally(() => {
    console.log("finally 호출");
  });
```

"출력" 호출 후, 2초 뒤 resolve를 통해 성공 리턴 값인 "sieun" 호출한 뒤에 finall() 호출
![](https://velog.velcdn.com/images/sieunpark/post/adc48b72-0e25-4b0e-89a4-56c00b678245/image.png)

<br>

즉, 성공하던 실패하던 상관 없이 어떤 기능을 마지막으로 수행하고 싶을 때 finall를 사용하는 것이다.

<br>

---

<br>

# ▶ 프로미스 연결 (Promise chaining)

> 프로미스를 연결할 때 Promise chaining을 사용한다.

```jsx
// Promise chaining
const fetchNumber = new Promise((resolve, reject) => {
  setTimeout(() => resolve(2), 1000);
});

fetchNumber
  .then((num) => num * 2)
  .then((num) => num * 3)
  .then((num) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => resolve(num - 1), 1000);
    });
  })
  .then((num) => console.log(num));
```

> fetchNumber Promise는 비동기적으로 1초 후에 숫자 2를 반환하고, 이후의 then 메서드 체인에서 각각의 비동기 작업을 순차적으로 처리하여 최종 결과를 출력한다. 자세한 과정은 아래와 같다.

- 1초 있다가 숫자 2를 전달하는 프로미스를 생성한다.

- 그 후 프로미스가 정상적으로 실행 되면 첫 번째 then 메서드에서는 이전에 해결(resolve)된 숫자를 가져와 2를 곱한다.

- 두 번째 then 메서드에서는 이전에 해결된 숫자를 가져와 3을 곱한다.

- 세 번째 then 메서드에서는 이전에 해결된 숫자를 가져와, 1을 뺀 값을 담은 새로운 Promise 객체를 생성한다. (then은 값을 바로 전달해도 되고 다른 비동기인 프로미스를 전달해도 됨)

- 마지막 then 메서드에서는 최종적으로 해결된 숫자를 가져와서 출력한다.

<br>

## ▷ 프로미스를 체이닝 오류 처리

> 프로미스를 체이닝했을 때 어떻게 오류를 해결하까? 예시를 통해 살펴보자

<br>

아래 코드는 3가지의 프로미스를 리턴한다.

> 1초 뒤 암탉 리턴 -> 암탉으로부터 받은 달걀 1초뒤 리턴 -> 달걀을 받아 1초뒤 후라이 리턴

```jsx
const getHen = () =>
  new Promise((resolve, reject) => {
    setTimeout(() => resolve("🐔", 1000));
  });

const getEgg = (hen) =>
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(`${hen}=>🥚`, 1000));
  });

const cook = (egg) =>
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(`${egg}=>🍳`, 1000));
  });
```

<br>

> 위 코드를 사용하여 서버에서 닭, 달걀, 요리까지 해보자!!!

```jsx
getHen() // (가독성을 이유로 여기에 주석을 쓴다.)
  .then((hen) => getEgg(hen))
  .then((egg) => cook(egg))
  .then((meal) => console.log(meal));
```

- getHen() 함수를 호출 후, 그 결과인 hen을 인자로 getEgg(hen) 함수를 호출하고, 다시 그 결과인 egg를 인자로 cook(egg) 함수를 호출
- 마지막으로 cook(egg) 함수의 결과인 meal이 console.log를 통해 출력(프로미스 체인 값 반환
  )
  ![](https://velog.velcdn.com/images/sieunpark/post/62642b73-fd4f-4393-beb8-0854a1094150/image.png)

<br>

> 콜백함수를 전달할 때 받아오는 값을 다른 함수로 바로 호출하는 경우 생략이 가능하다. (이해x)

```jsx
getHen() //
  .then(getEgg)
  .then(cook)
  .then(console.log);
```

![](https://velog.velcdn.com/images/sieunpark/post/37c6fbc3-8c4b-4db0-9c31-6ff11dae0688/image.png)

<br>

만약 댤걀을 받아올 때 네트워크에 문제가 생겨 실패가 되면 어떻게 처리해야할까?

실패시 new Error object 이용

```jsx
const getEgg = (hen) =>
  new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error(`error! ${hen}=>🥚`)), 1000);
  });
```

위와 같이 에러 처리를 해주면 아래와 같이 출력이 된다.
![](https://velog.velcdn.com/images/sieunpark/post/2397a1e3-fd51-46f7-91b6-d98fd94f5578/image.png)
어떤 에러 핸들링도 하지 않았기 때문에 에러가 발생한다.

<br>

```jsx
getHen() //
  .then(getEgg)
  .then(cook)
  .then(console.log)
  .catch(console.log);
```

따라서 마지막에 .catch() 메서드를 사용하여 프로미스 체인에서 발생하는 오류를 처리하였다.

> 프로미스 체인에서 한 단계에서라도 오류가 발생하면, 해당 오류는 체인의 다음 .catch() 메서드로 전달된다.

이를 통해 오류를 적절하게 처리할 수 있는 것이다.
![](https://velog.velcdn.com/images/sieunpark/post/1d908101-6b83-4046-9d8e-8754fb016bba/image.png)

<br>

> .catch() 메서드를 사용해 달걀을 받아올 때 문제가 생긴다면 다른 재료로 대처하는 에러 핸들링을 처리해보자

```jsx
getHen() //
  .then(getEgg)
  .catch((error) => {
    return "🧙🏻";
  })
  .then(cook)
  .then(console.log)
  .catch(console.log);
```

계란을 받아오는 것에 문제가 생겨도 전체적인 프로미스 체인에 문제가 발생하지 않도록 처리를 해주었다.

![](https://velog.velcdn.com/images/sieunpark/post/97102680-990e-45a2-ae4b-2d9259e9eb83/image.png)

<br>

> ➡️ 이렇게 에러를 처리하고 싶을 떄 .catch() 메서드를 사용하여 바로바로 문제를 해결할 수 있다.

<br>

---

<br>

# ▶ 코드 리팩토링

이전에 했던 예시인 콜백함수를 프로미스로 변경해보자!

- 콜백함수

```jsx
setTimeout(
  function (name) {
    var coffeeList = name;
    console.log(coffeeList);

    setTimeout(
      function (name) {
        coffeeList += ", " + name;
        console.log(coffeeList);

        setTimeout(
          function (name) {
            coffeeList += ", " + name;
            console.log(coffeeList);

            setTimeout(
              function (name) {
                coffeeList += ", " + name;
                console.log(coffeeList);
              },
              500,
              "카페라떼"
            );
          },
          500,
          "카페모카"
        );
      },
      500,
      "아메리카노"
    );
  },
  500,
  "에스프레소"
);
```

<br>

- 프로미스로 변경

```jsx
new Promise(function (resolve) {
  setTimeout(function () {
    var name = "에스프레소";
    console.log(name);
    resolve(name);
  }, 500);
})
  .then(function (prevName) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        var name = prevName + ", 아메리카노";
        console.log(name);
        resolve(name);
      }, 500);
    });
  })
  .then(function (prevName) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        var name = prevName + ", 카페모카";
        console.log(name);
        resolve(name);
      }, 500);
    });
  })
  .then(function (prevName) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        var name = prevName + ", 카페라떼";
        console.log(name);
        resolve(name);
      }, 500);
    });
  });
```

<br>

- 위 코드의 반복적인 로직을 함수화 시켜보자

```jsx
var addCoffee = function (name) {
  // 변수 이름을 name으로 받음
  return function (prevName) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        // 백틱
        var nameName = prevName ? `${prevName}, ${name}` : name;
        console.log(name);
        resolve(nameName);
      }, 500);
    });
  };
};
addCoffee("에스프레소")()
  .then(addCoffee("아메리카노"))
  .then(addCoffee("카페모카"))
  .then(addCoffee("카페라떼"));
```

<br>

---

<br>

# 📎참조

- https://www.youtube.com/watch?v=JB_yU6Oe2eE&t=508s
