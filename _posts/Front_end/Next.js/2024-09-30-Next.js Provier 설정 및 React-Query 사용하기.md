---
title: "[Next.js] Next.js Provier 설정 및 React-Query 사용하기"
categories: [Next.js]
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

# 1. React Query 기본 설정

## 1.1 app/providers.tsx 생성

> 기본적으로 `layout.tsx`는 서버 컴포넌트로 동작한다. 따라서 클라이언트 전용 컴포넌트인 `provider`를 루트 레이아웃에서 직접 사용할 수 없다.

따라서 `app/providers.tsx`에 provider을 `use client`지시어를 사용하여 클라이언트 컴포넌트로 만들어 서버 컴포넌트인 `layout.tsx`에 주입하여야 한다.

```tsx
// app/providers.tsx
"use client"; // 클라이언트 컴포넌트로 지정

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

// 클라이언트 컴포넌트로 React Query Provider 정의

const Providers = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient();

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

export default Providers;
```

<br>

> `provider` 추가시 아래와 같이 확장할 수 있다.

```tsx
// app/providers.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { SessionProvider } from "next-auth/react";

const Providers = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient();

  return (
    <SessionProvider>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </SessionProvider>
  );
};

export default Providers;
```

<br>

## 1.2 layout.tsx에서 Provider 주입

> 이제 생성한 `providers`를 `root layout`에 주입하여 하위 컴포넌트에서 React Query를 사용할 수 있도록 하자.

```tsx
import type { Metadata } from "next";
import "./globals.css";
import Providers from "./providers";

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body>
        {/* 클라이언트 컴포넌트인 ReactQueryProvider로 감싸줌 */}
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

<br><br>

# 2. React Query 사용하기

제대로 `QueryClientProvider`가 주입되었는지 확인해보자!

## 2.1 JSON Server 설치 및 데이터 설정

> 먼저 json-server을 설치하자

```shell
yarn global add json-server
```

<br>

> 그 후, `db.json` 파일을 만들어 아래와 같은 내용을 넣어주자. 이 json 파일을 db로 사용한다.

```json
{
  "posts": [
    { "id": "1", "title": "타이틀1", "content": "내용1" },
    { "id": "2", "title": "타이틀2", "content": "내용2" }
  ]
}
```

<br>

> 아래 명령어를 통해 `json-server`을 실행하자.

```shell
json-server --watch db.json --port 4000
```

<br>

## 2.2 useQuery 사용

`use client` 지시어는 `useQuery`와 `useMutation`을 사용할 때 필요하다.

```tsx
"use client";

import { useQuery } from "@tanstack/react-query";

import axios from "axios";

interface Post {
  id: string;
  title: string;
  content: string;
}

export const fetchTodos = async () => {
  try {
    const response = await axios.get("http://localhost:4000/posts");
    return response.data;
  } catch (error) {
    console.error(error);
  }
};

export default function Home() {
  const {
    data: posts,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["posts"],
    queryFn: fetchTodos,
  });

  if (isLoading) {
    return <p>로딩중...</p>;
  }

  if (error) {
    return <p>에러 발생!</p>;
  }

  return (
    <div>
      {posts?.map((post: Post) => (
        <ul key={post.id}>
          <li>{post.title}</li>
          <li>{post.content}</li>
        </ul>
      ))}
    </div>
  );
}
```

위 코드를 적용한 후, 페이지를 로드하면 아래와 같이 정상적으로 데이터가 표시된다.

![](/assets/images/2024/2024-09-30-17-01-53.png)

<br>

## 2.3 부록 - React Query 효율적 구조 설계하기

> [[React Query 효율적 구조 설계에 대한 고찰↗️]](https://mynamesieun.github.io/react/React-Query-%ED%9A%A8%EC%9C%A8%EC%A0%81-%EA%B5%AC%EC%A1%B0-%EC%84%A4%EA%B3%84%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B3%A0%EC%B0%B0/)포스팅을 참고하여 React Query를 보다 효율적으로 구조화하도록 하자.

이 포스팅에서는 간단히 Next.js에서 React-Query를 사용하는 것만 다루기 때문에 꼭 위 포스팅을 참고하여 React-Query 사용 시 효율적으로 프로젝트 구조를 설계하도록 하자.

<br><br>

# 3. prefetchQuery로 성능 최적화하기

## 3.1 prefetchQuery 개요

> `prefetchQuery`는 페이지나 컴포넌트를 렌더링하기 전에 **서버에서 데이터를 미리 로드하여 캐시에 저장하는** 기능이다.

- 데이터를 미리 가져올 수 있으므로 필요할 때 클라이언트 컴포넌트에서 다시 한 번 `useQuery`로 가져올 필요가 없으며, 데이터를 즉시 사용할 수 있도록 한다.
- `prefetchQuery`가 없으면 클라이언트 사이드 렌더링처럼 작동하기 때문에 SEO가 제대로 인식하지 못할 수 있지만, `prefetchQuery`를 사용하면 초기 로드 시 데이터를 미리 받아오기 때문에 SEO 성능이 향상될 수 있다.
- 위에서 작성한 코드를 `prefetchQuery`를 사용하여 페이지가 렌더되기 전에 사용해 데이터를 미리 패치하는 방식으로 개선해보자.

<br>

## 3.2 prefetchQuery 장점

> `prefetchQuery`를 사용하면 아래와 같은 장점이 존재한다.

1. 빠른 초기 로드: `Providers` 컴포넌트가 렌더될 때 필요한 데이터를 미리 패칭하도록 설정할 수 있어, 사용자가 페이지에 처음 도착했을 때 데이터를 미리 로드해, 로딩 시간을 단축할 수 있다.
2. 캐시된 데이터 재사용: useQuery를 통해 데이터가 이미 캐시에 있을 경우, 네트워크 요청 없이 바로 캐시된 데이터를 사용한다.
3. SEO 개선: `getServerSideProps`와 함께 사용하여 서버 측에서 데이터를 미리 패칭하면, 클라이언트 사이드에서 데이터 로드가 필요하지 않아 SEO에 유리하다.

<br>

## 3.3 prefetchQuery 사용 방법

> ① `Providers` 컴포넌트에서 `prefetchQuery` 적용

- 다음과 같이 `Providers` 컴포넌트에 `prefetchQuery`를 적용하여 `posts` 데이터를 미리 패칭한 후 캐시에 저장해 둔다.
- 따라서 컴포넌트가 렌더링될 때 해당 데이터를 `useQuery`를 통해 즉시 사용할 수 있다.

```tsx
// app/providers.tsx
"use client"; // 클라이언트 컴포넌트로 지정

import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { fetchTodos } from "./page";

// 클라이언트 컴포넌트로 React Query Provider 정의
const Providers = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient();

  // 데이터 미리 패치 (프리패치)
  queryClient.prefetchQuery({
    queryKey: ["posts"],
    queryFn: fetchTodos,
  });

  const dehydratedState = dehydrate(queryClient);

  return (
    <QueryClientProvider client={queryClient}>
      {/* HydrationBoundary안에서만 프리패칭 적용 */}
      <HydrationBoundary state={dehydratedState}>{children}</HydrationBoundary>
    </QueryClientProvider>
  );
};

export default Providers;
```

<br>

> ② Home 컴포넌트의 로딩 속도 개선

- `Home` 컴포넌트에서는 useQuery를 통해 데이터를 패칭하고 있으므로, 위에서 미리 패칭된 데이터가 존재할 경우 즉시 캐시된 데이터를 가져온다.
- 즉, useQuery를 평소 사용하던 방식으로 사용하면 되지만, 이미 캐시된 데이터가 존재하면 빠르게 데이터를 렌더링할 수 있는 것이다.

```tsx
"use client";

import { useQuery } from "@tanstack/react-query";

import axios from "axios";
import { Post } from "./types/post-types";

export const fetchTodos = async () => {
  try {
    const response = await axios.get("http://localhost:4000/posts");
    return response.data;
  } catch (error) {
    console.error(error);
  }
};

export default function Home() {
  const {
    data: posts,
    isLoading,
    error,
  } = useQuery({
    queryKey: ["posts"],
    queryFn: fetchTodos,
  });

  if (isLoading) {
    return <p>로딩중...</p>;
  }

  if (error) {
    return <p>에러 발생!</p>;
  }

  return (
    <div>
      {posts?.map((post: Post) => (
        <ul key={post.id}>
          <li>{post.title}</li>
          <li>{post.content}</li>
        </ul>
      ))}
    </div>
  );
}
```

<br><br>

# 4. 개선(작성중)

ReactQueryStreamedHydration 사용

[[공식문서↗️]](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr)의 맨 아래에 나와있음

설치

```
yarn add @tanstack/react-query-devtools
yarn add @tanstack/react-query-next-experimental
```

```tsx
"use client"; // 클라이언트 컴포넌트로 지정

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
import { ReactQueryStreamedHydration } from "@tanstack/react-query-next-experimental";

// 클라이언트 컴포넌트로 React Query Provider 정의
const Providers = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient();

  return (
    <QueryClientProvider client={queryClient}>
      {/* HydrationBoundary안에서만 프리패칭 적용 */}
      <ReactQueryStreamedHydration>{children}</ReactQueryStreamedHydration>
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
};

export default Providers;
```

<br>

`useQuery`가 아닌, `useSuspenseQuery`를 사용해야 함

```tsx
"use client";

import { useSuspenseQuery } from "@tanstack/react-query";

import axios from "axios";
import { Post } from "./types/post-types";

export const fetchTodos = async () => {
  try {
    const response = await axios.get("http://localhost:4000/posts");
    return response.data;
  } catch (error) {
    console.error(error);
  }
};

export default function Home() {
  const {
    data: posts,
    isLoading,
    error,
  } = useSuspenseQuery({
    queryKey: ["posts"],
    queryFn: fetchTodos,
  });

  if (isLoading) {
    return <p>로딩중...</p>;
  }

  if (error) {
    return <p>에러 발생!</p>;
  }

  return (
    <div>
      {posts?.map((post: Post) => (
        <ul key={post.id}>
          <li>{post.title}</li>
          <li>{post.content}</li>
        </ul>
      ))}
    </div>
  );
}
```

![](/assets/images/2024/2024-10-01-01-26-12.png)

<br>
