---
title: "[Next.js] Next.js에서 NextAuth를 사용한 인증 구현하기"
toc_label: Contents
toc: true
toc_sticky: true
author_profile: true
sidebar:
  nav: "counts"
---

<br>

---

[[Next.js에서 NextAuth를 사용한 인증 구현하기 Repo↗️]](https://github.com/MyNameSieun/Nextjs-Authentication)

---

<br>

# 1. NextAuth 개요

## 1.1 NextAuth 란?

[[NextAuth 공식 문서↗️]](https://next-auth.js.org/)

> NextAuth.js는 Next.js App에 인증 기능을 쉽게 추가할 수 있는 라이브러리이다.

- 백엔드로부터 로그인 이후 `Authentication`등의 정보를 받아와야 한다.
- 그리고 `access token`, `refresh token`등 정보를 별도 공간에 저장하고 관리해야 한다.
- 지금까지 access token을 localStorage에 단순하게 저장 하였지만, 이는 보안 문제가 발생할 수 있다.

<br>

## 1.2 NextAuth의 장점

> 간편한 설정

설정이 간단하여 복잡한 인증 로직 없이도 빠르게 인증 기능을 구현할 수 있다.

> 다양한 Authentication Providers 지원

GitHub, Google, Facebook, Twitter 등 다양한 인증 제공자를 사용할 수 있다.

> 세션 관리

NextAuth는 사용자 세션을 자동으로 관리하여, 세션 상태를 쉽게 확인하고 갱신할 수 있다.

> 보안

CSRF 공격 방지, JWT(JSON Web Token) 지원, 사용자 비밀번호 암호화 등 보안 관련 기능을 제공한다.

<br><br>

# 2. NextAuth 설치 및 세팅

## 2.1 설치

```shell
yarn add next-auth
```

<br>

## 2.2 라우팅 설정

> app 폴더 안에 `page.tsx`를 생성하여 라우팅을 설정하자.

- (🔒 auth): 인증이 필요한 페이지
- (🔓 nonAuth): 인증이 필요하지 않은 페이지
- api/auth/[...nextauth]: NextAuth API 라우트

```
📂 app
│  ├── 📄 favicon.ico
│  ├── 🎨 globals.css
│  ├── 📄 layout.tsx
│  ├── 📄 page.tsx
│  ├── 📄 provider.tsx
│
├─ 📂 (🔒 auth)
│  └─ 📂 todo
│      ├── 📄 layout.tsx
│      │
│      ├─ 📂 my
│      │   └── 📄 page.tsx
│      │
│      └─ 📂 new
│          └── 📄 page.tsx
│
├─ 📂 (🔓 nonAuth)
│  ├─ 📂 home
│  │   └── 📄 page.tsx
│  │
│  ├─ 📂 signin
│  │   └── 📄 page.tsx
│  │
│  └─ 📂 signup
│      └── 📄 page.tsx
│
├─ 📂 api
│  └─ 📂 auth
│      └─ 📂 [...nextauth]
│          └── 📄 route.ts
│
├─ 📂 components
│  └─ 📂 layouts
│      ├── 📄 Header.tsx
│      │
│      └─ 📂 common
│          └── 📄 SignInOutButton.tsx
│
└─ 📂 fonts
    ├── 🎶 GeistMonoVF.woff
    └── 🎶 GeistVF.woff
```

<br>

## 2.3 provider 세팅

> 인증 세션을 관리하기 위해 `SessionProvider`를 설정해야 한다.

- `SessionProvider`를 설정하여 애플리케이션의 모든 컴포넌트가 인증 세션에 접근할 수 있도록 한다.
- provider은 client 컴포넌트인데 root layout은 클라이언트 컴포넌트가 안 되므로 root layout에 provider을 use client로 만들어 주입해야하는 것이다.

```tsx
// app/providers.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { SessionProvider } from "next-auth/react";

const Provider = ({ children }: { children: React.ReactNode }) => {
  const queryClient = new QueryClient();

  return (
    <SessionProvider>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </SessionProvider>
  );
};

export default Provider;
```

- `SessionProvider`: 애플리케이션의 모든 컴포넌트가 인증 세션에 접근할 수 있도록 한다.
- `QueryClientProvider`: 애플리케이션의 컴포넌트가 리액트 쿼리를 사용할 수 있도록 한다.

<br>

## 2.4 RootLayout 세팅

> Next.js 애플리케이션의 레이아웃을 설정하는 `app/layout.tsx` 파일이다.

위에서 생성한 `Providers`로 감싸주어 모든 자식 컴포넌트에서 인증 상태에 접근할 수 있도록 하자.

```tsx
// app/layout.tsx
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ko">
      <body className={inter.className}>
        <Providers>
          <Header />
          {children}
        </Providers>
      </body>
    </html>
  );
}
```

<br>

## 2.5 next.config.mjs 세팅

> Next.js의 리디렉션 설정을 포함하는 파일이다.

- 아래와 같이 설정하면 루트 경로( `/` )에 접근 시 `/home`으로 리디렉션된다.
- 리디렉션은 브라우저 캐시에 저장될 수 있다. 따라서 리디렉션 설정을 변경한 후에는 브라우저의 캐시를 지워야 한다.

```tsx
// next.config.mjs
/** @type {import('next').NextConfig} */
const nextConfig = {
  async redirects() {
    return [
      {
        source: "/",
        destination: "/home",
        permanent: true,
      },
    ];
  },
};

export default nextConfig;
```

<br>

## 2.6 Header.tsx 설정

> 사용자의 인증 상태에 따라 로그인 또는 로그아웃 버튼을 표시하는 `Header.jsx` 컴포넌트를 생성하자.

```tsx
// app/components/layouts/Header.tsx
import Link from "next/link";
import SignInOutButton from "../common/SignInOutButton";

const Header = () => {
  return (
    <header className="flex justify-between p-4 border">
      <section>
        <Link href="/home">Logo</Link>
      </section>
      <nav className="flex gap-8">
        <Link href="/home">Home</Link>
        <Link href="/todo/my">My Todo</Link>
        <Link href="/todo/new">New Todo</Link>
      </nav>
      <section>
        <SignInOutButton />
      </section>
    </header>
  );
};

export default Header;
```

<br>

> SignInOutButton.tsx

`SignInOutButton.tsx`는 인증 상태에 따라 로그인 또는 로그아웃 버튼을 표시한다.

```tsx
// app/components/common/SignInOutButton.tsx
"use client";

import { signIn, signOut, useSession } from "next-auth/react";

const SignInOutButton = () => {
  const session = useSession();
  const isSignIn = session.status === "authenticated";

  return isSignIn ? (
    <>
      <button onClick={() => signOut()}>로그아웃</button>
    </>
  ) : (
    <>
      <button onClick={() => signIn()}>로그인</button>
    </>
  );
};

export default SignInOutButton;
```

<br>

## 2.7 TodoLayout 세팅

> 인증된 사용자만 접근할 수 있는 레이아웃을 설정한다.

`shouldRender` 값이 `true`일 때만 children이 렌더링되므로, 자식 요소들이 화면에 나타나는 조건이 `TodoLayout` 내부의 상태에 따라 결정된다.

```tsx
// app/(auth)/todo/layout.tsx
"use client";

import { useSession } from "next-auth/react";
import { useRouter } from "next/navigation"; // 주의! navigation에서 가져와야 함
import { useEffect, useState } from "react";

const TodoLayout = ({ children }: { children: React.ReactNode }) => {
  const sesstion = useSession();
  const router = useRouter();
  const [shouldRender, setShouldRender] = useState(false);

  useEffect(() => {
    if (sesstion.status != "authenticated") {
      // 로그인 상태가 아니라면
      router.replace("/signin");
    } else {
      // 로그인이 되어있다면
      setShouldRender(true);
    }
  }, []);

  return <div>{shouldRender && children}</div>;
};

export default TodoLayout;
```

- `useEffect`: 사용자의 인증 상태를 확인하고, 인증되지 않은 경우 로그인 페이지로 리디렉션한다.

<br><br>

# 3. NextAuth 로그인/로그아웃 구현

## 3.1 NextAuth handler 설정

> NextAuth.js를 설정하기 위해, Next.js의 API 라우트를 생성해야 한다.

`app/api/auth/[...nextauth]/route.ts`에 파일을 생성하여, 다음과 같이 NextAuth 핸들러를 설정하자. (⚠️ 경로 똑같이 지정할 것)

```tsx
// app/api>auth/[...nextauth]/route.ts
import NextAuth from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";

const handler = NextAuth({
  providers: [
    CredentialsProvider({
      id: "id-password-credential", // 꼭 설정 할 것 (목차 3.3과 연결)
      name: "Credentials",
      type: "credentials",
      // credentials안에 있는 요소들은 목차 3.3의 input과 연결
      credentials: {
        id: {
          label: "아이디",
          type: "text",
          placeholder: "아이디를 입력해주세요.",
        },
        password: {
          label: "비밀번호",
          type: "password",
          placeholder: "비밀번호를 입력해주세요.",
        },
      },
      async authorize(credentials, req) {
        // 로그인 요청을 처리하는 부분
        const res = await fetch("http://moneyfulpublicpolicy.co.kr/login", {
          method: "POST",
          body: JSON.stringify(credentials),
          headers: {
            "Content-Type": "application/json",
          },
        });

        const user = await res.json();

        if (res.ok && user) {
          return user; // 인증 성공 시 사용자 정보 반환
        }
        return null; // 인증 실패 시 null 반환
      },
    }),
  ],
  pages: {
    signIn: "/signin", // 사용자 정의 로그인 페이지 (커스터마이징)
  },
  secret: "secret",
});

export { handler as GET, handler as POST };
```

- `CredentialsProvider`: 사용자가 입력한 아이디와 비밀번호로 인증을 처리한다.
- `authorize()`: 사용자로부터 받은 자격 증명을 기반으로 API에 요청을 보내고, 인증이 성공하면 사용자 정보를 반환한다.

<br>

## 3.2 Home.tsx에서 로그인 여부 확인

> 사용자가 로그인했는지 확인하는 페이지를 만든다.

```tsx
// app/(non-auth)/home/page.tsx
"use client";

import { useSession } from "next-auth/react";

const HomePage = () => {
  const session = useSession();

  console.log("====================================");
  console.log("HomePage", session);
  console.log("====================================");
  return <div>HomePage</div>;
};

export default HomePage;
```

- `useSession`: 현재 세션의 상태를 확인한다.

<br>

## 3.3 로그인 기능 구현

> 기본적으로 제공하는 NextAuth 로그인 페이지를 커스터마이징을 할 수 있다.

로그아웃 페이지도 로그인 페이지처럼 똑같이 해주면 된다.

```tsx
// src/app/(non-auth)/signin/page.tsx
"use client";
import { signIn, useSession } from "next-auth/react";
import { usePathname, useRouter } from "next/navigation";
import { useEffect, useState } from "react";

const SigninPage = () => {
  const router = useRouter();
  const pathname = usePathname();
  const session = useSession();

  const [shouldRender, setShouldRender] = useState(false);
  const [id, setId] = useState("");
  const [password, setPassword] = useState("");

  useEffect(() => {
    if (session.status === "authenticated") {
      router.replace("/"); // 인증된 경우 홈으로 리디렉션
    } else {
      setShouldRender(true);
    }

    console.log("session", session);
  }, [router, session, pathname]);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    try {
      // 위에서(목차 3.1) 설정한 id와 연결
      const response = await signIn("id-password-credential", {
        id,
        password,
        redirect: false,
      });
    } catch (error) {
      console.error("에러 발생");
    }

    return false;
  };

  return (
    <div>
      {shouldRender && (
        <form onSubmit={handleSubmit}>
          <>
            <label htmlFor="id">아이디</label>
            <input
              id="id"
              type="text"
              name="id"
              value={id}
              onChange={(e) => setId(e.target.value)}
            />
          </>
          <>
            <label htmlFor="password">비밀번호</label>
            <input
              id="password"
              type="password"
              name="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
          </>
          <button
            className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-full"
            type="submit"
          >
            로그인하기
          </button>
        </form>
      )}
    </div>
  );
};

export default SigninPage;
```

- `signIn()`: 입력된 자격 증명을 사용하여 인증을 시도한다.
- 로그인 성공 시: 사용자 세션 상태가 변경되며, 로그인 상태에 따라 다른 컴포넌트를 렌더링한다.

<br>
